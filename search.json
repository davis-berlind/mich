[{"path":"https://davis-berlind.github.io/mich/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 mich authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://davis-berlind.github.io/mich/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Davis Berlind. Author, maintainer.","code":""},{"path":"https://davis-berlind.github.io/mich/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Berlind D (2025). mich: Bayesian Change-Point Detection Credible Sets. R package version 0.0.0.9000, https://davis-berlind.github.io/mich/.","code":"@Manual{,   title = {mich: Bayesian Change-Point Detection with Credible Sets},   author = {Davis Berlind},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://davis-berlind.github.io/mich/}, }"},{"path":"https://davis-berlind.github.io/mich/index.html","id":"fast-bayesian-inference-for-change-point-detection","dir":"","previous_headings":"","what":"Bayesian Change-Point Detection with Credible Sets","title":"Bayesian Change-Point Detection with Credible Sets","text":"mich R package implements Multiple Independent Change-Point (MICH) method introduced Berlind, Cappello, Madrid Padilla (2025). main function package mich() takes length TT sequence observations ùê≤1:T\\mathbf{y}_{1:T} potentially many change-points mean variance, deploys backfitting procedure find variational approximation posterior distribution change-points.","code":""},{"path":"https://davis-berlind.github.io/mich/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bayesian Change-Point Detection with Credible Sets","text":"can install development version mich GitHub using:","code":"# install.packages(\"devtools\") devtools::install_github(\"davis-berlind/mich\")"},{"path":"https://davis-berlind.github.io/mich/reference/cred_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Single Change-Point Posterior Credible Set ‚Äî cred_set","title":"Single Change-Point Posterior Credible Set ‚Äî cred_set","text":"function cred_set() takes length \\(T\\) vector posterior change-point location probabilities \\(\\pi_{1:T}\\) coverage level \\(\\alpha\\), returns smallest set \\(S\\) \\(\\Sigma_{t \\S} \\pi_t \\geq \\alpha\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/cred_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Single Change-Point Posterior Credible Set ‚Äî cred_set","text":"","code":"cred_set(prob, level)"},{"path":"https://davis-berlind.github.io/mich/reference/cred_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Single Change-Point Posterior Credible Set ‚Äî cred_set","text":"prob numeric vector. vector posterior probabilities location change-point. level scalar. single number (0,1) gives lower bound probability credible set contains change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/cred_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Single Change-Point Posterior Credible Set ‚Äî cred_set","text":"vector. Level level posterior credible set location single change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/integer_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Integer value check. ‚Äî integer_check","title":"Integer value check. ‚Äî integer_check","text":"integer_check() throws error n equal positive valued integer.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/integer_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integer value check. ‚Äî integer_check","text":"","code":"integer_check(n)"},{"path":"https://davis-berlind.github.io/mich/reference/integer_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integer value check. ‚Äî integer_check","text":"n integer.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/integer_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integer value check. ‚Äî integer_check","text":"integer. error thrown evaluation, integer_check() returns n argument.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/lambda_bar_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected Precision Signal ‚Äî lambda_bar_fn","title":"Expected Precision Signal ‚Äî lambda_bar_fn","text":"Given \\(V(y_t|s,\\tau)=1/\\lambda_t=1/s^{(t\\geq \\tau)}\\), \\(P(\\tau=t)=\\pi_t\\), \\(\\bar{u}_t/\\bar{v}_t=E[s|\\tau=t]\\), lambda_bar_fn() calculates \\(E[\\lambda_t]\\) \\(1 - \\Sigma_{t'=1}^t \\pi_{t'}(1 - \\bar{v}_{t'} / \\bar{u}_{t'})\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/lambda_bar_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected Precision Signal ‚Äî lambda_bar_fn","text":"","code":"lambda_bar_fn(u, v, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/lambda_bar_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected Precision Signal ‚Äî lambda_bar_fn","text":"u numeric vector. Length \\(T\\) vector conditional shape parameters v numeric vector. Length \\(T\\) vector conditional rate parameters prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/lambda_bar_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected Precision Signal ‚Äî lambda_bar_fn","text":"numeric vector. length \\(T\\) vector \\(E[\\lambda_t]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_mean_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Weighted Mean-SCP Prior ‚Äî log_mean_prior","title":"Log Weighted Mean-SCP Prior ‚Äî log_mean_prior","text":"Log weighted prior Mean-SCP model described Appendix C.2 Berlind, Cappello, Madrid Padilla (2025). prior ensures absence change-point, posterior probabilities approximately uniform.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_mean_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Weighted Mean-SCP Prior ‚Äî log_mean_prior","text":"","code":"log_mean_prior(T, d)"},{"path":"https://davis-berlind.github.io/mich/reference/log_mean_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Weighted Mean-SCP Prior ‚Äî log_mean_prior","text":"T integer. Number observations (rows) \\(\\mathbf{y}_{1:T}\\). d integer. Dimension (columns) \\(\\mathbf{y}_{1:T}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_mean_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Weighted Mean-SCP Prior ‚Äî log_mean_prior","text":"numeric vector. Log prior probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_meanvar_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Weighted MeanVar-SCP Prior ‚Äî log_meanvar_prior","title":"Log Weighted MeanVar-SCP Prior ‚Äî log_meanvar_prior","text":"Log weighted prior MeanVar-SCP model described Appendix C.2 Berlind, Cappello, Madrid Padilla (2025). prior ensures absence change-point, posterior probabilities approximately uniform.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_meanvar_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Weighted MeanVar-SCP Prior ‚Äî log_meanvar_prior","text":"","code":"log_meanvar_prior(T)"},{"path":"https://davis-berlind.github.io/mich/reference/log_meanvar_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Weighted MeanVar-SCP Prior ‚Äî log_meanvar_prior","text":"T integer. Number observations \\(y_{1:T}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_meanvar_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Weighted MeanVar-SCP Prior ‚Äî log_meanvar_prior","text":"numeric vector. Log prior probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_var_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Weighted Var-SCP Prior ‚Äî log_var_prior","title":"Log Weighted Var-SCP Prior ‚Äî log_var_prior","text":"Log weighted prior Var-SCP model described Appendix C.2 Berlind, Cappello, Madrid Padilla (2025). prior ensures absence change-point, posterior probabilities approximately uniform.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_var_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Weighted Var-SCP Prior ‚Äî log_var_prior","text":"","code":"log_var_prior(T)"},{"path":"https://davis-berlind.github.io/mich/reference/log_var_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Weighted Var-SCP Prior ‚Äî log_var_prior","text":"T integer. Number observations \\(y_{1:T}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_var_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Weighted Var-SCP Prior ‚Äî log_var_prior","text":"numeric vector. Log prior probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/logical_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical value check. ‚Äî logical_check","title":"Logical value check. ‚Äî logical_check","text":"logical_check() throws error x equal either TRUE FALSE.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/logical_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical value check. ‚Äî logical_check","text":"","code":"logical_check(x)"},{"path":"https://davis-berlind.github.io/mich/reference/logical_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical value check. ‚Äî logical_check","text":"x logical.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/logical_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical value check. ‚Äî logical_check","text":"logical. error thrown evaluation, logical_check() returns x argument.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mean_scp.html","id":null,"dir":"Reference","previous_headings":"","what":"Mean Single Change-Point Model ‚Äî mean_scp","title":"Mean Single Change-Point Model ‚Äî mean_scp","text":"Implementation univariate Mean-SCP model Berlind, Cappello, Madrid Padilla (2025). function mean_scp() takes length \\(T\\) vector \\(y_{1:T}\\) single mean change returns posterior distribution change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mean_scp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mean Single Change-Point Model ‚Äî mean_scp","text":"","code":"mean_scp(y, lambda, omega, log_pi)"},{"path":"https://davis-berlind.github.io/mich/reference/mean_scp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mean Single Change-Point Model ‚Äî mean_scp","text":"y numeric vector. \\(T\\) observations single variance change. lambda numeric vector. Precision vector y. omega positive scalar. Prior precision parameter. log_pi numeric vector. Vector log prior probabilities location change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mean_scp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mean Single Change-Point Model ‚Äî mean_scp","text":"list. list posterior parameters including mean b_bar, precision omega_bar, posterior probabilities change-point location pi_bar.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/meanvar_scp.html","id":null,"dir":"Reference","previous_headings":"","what":"Mean-Variance Single Change-Point Model ‚Äî meanvar_scp","title":"Mean-Variance Single Change-Point Model ‚Äî meanvar_scp","text":"Implementation MeanVar-SCP model Berlind, Cappello, Madrid Padilla (2025). function meanvar_scp() takes length \\(T\\) vector \\(y_{1:T}\\) single joint mean variance change returns posterior distribution change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/meanvar_scp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mean-Variance Single Change-Point Model ‚Äî meanvar_scp","text":"","code":"meanvar_scp(y, lambda, omega, u_bar, lgamma_u_bar, v, log_pi)"},{"path":"https://davis-berlind.github.io/mich/reference/meanvar_scp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mean-Variance Single Change-Point Model ‚Äî meanvar_scp","text":"y numeric vector. \\(T\\) observations single joint mean variance change. lambda numeric vector. Known trend component precision y. omega positive scalar. Prior precision parameter. u_bar numeric vector. Posterior shape parameters equal \\(u_0 + T - t + 1\\) \\(t\\). lgamma_u_bar numeric vector. Log gamma function evaluated u_bar. v numeric vector. Vector prior rate parameters \\(t\\). log_pi numeric vector. Vector log prior probabilities location change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/meanvar_scp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mean-Variance Single Change-Point Model ‚Äî meanvar_scp","text":"list. list posterior parameters including  mean b_bar, precision omega_bar, rate v_bar, posterior probabilities change-point location pi_bar.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiple Independent Change-Point (MICH) Model ‚Äî mich","title":"Multiple Independent Change-Point (MICH) Model ‚Äî mich","text":"Implementation MICH model described Berlind, Cappello, Madrid Padilla. MICH Bayesian change-point detection method can quantify uncertainty around estimated change-points form credible sets.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiple Independent Change-Point (MICH) Model ‚Äî mich","text":"","code":"mich(   y,   fit_intercept = TRUE,   fit_scale = TRUE,   standardize = TRUE,   J = 0,   L = 0,   K = 0,   J_auto = FALSE,   L_auto = FALSE,   K_auto = FALSE,   J_max = Inf,   L_max = Inf,   K_max = Inf,   tol = 1e-05,   merge_prob = NULL,   merge_level = 0.95,   max_iter = 10000,   verbose = FALSE,   reverse = FALSE,   restart = TRUE,   increment = 1,   omega_j = 0.001,   u_j = 0.001,   v_j = 0.001,   pi_j = \"weighted\",   omega_l = 0.001,   pi_l = \"weighted\",   u_k = 0.001,   v_k = 0.001,   pi_k = \"weighted\" )"},{"path":"https://davis-berlind.github.io/mich/reference/mich.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiple Independent Change-Point (MICH) Model ‚Äî mich","text":"y numeric vector matrix. length \\(T\\) vector observations exhibiting change-points mean /variance series, \\(T \\times d\\) matrix observations exhibiting just mean changes. fit_intercept logical. fit_intercept == TRUE, intercept estimated, otherwise assumed  \\(\\mu_0 = 0\\). fit_scale logical. fit_scale == TRUE, initial precision estimated, otherwise assumed  \\(\\lambda_0 = 1\\) (\\(\\Lambda_0 = \\mathbf{}_d\\) y matrix). standardize logical. standardize == TRUE, y centered rescaled fitting. L, J, K Integers. Respective number mean-scp, var-scp, meanvar-scp components included model. L_auto == TRUE, K_auto == TRUE, J_auto == TRUE L, K, J lower bound number kind change-point model. L_auto, K_auto, J_auto Logicals. L_auto == TRUE, K_auto == TRUE, /J_auto == TRUE, mich_vector() searches forr returns \\(L\\) L L_max, \\(K\\) K K_max, /\\(J\\) J J_max maximize ELBO (see Appendix C.4 Berlind, Cappello, Madrid Padilla (2025)). L_max, K_max, J_max Integers. L_auto == TRUE, K_auto == TRUE, J_auto == TRUE L_max, K_max, J_max upper bound number kind change-point model. tol scalar. Convergence tolerance relative increase ELBO. \\((\\text{ELBO}_{t+1}-\\text{ELBO}_t)/ \\text{ELBO}_t\\) falls tol variational algorithm terminates. merge_prob scalar. value (0,1) indicating merge criterion. posterior probability two components identify change greater merge_level, components merged (see Appendix C.3 Berlind, Cappello, Madrid Padilla (2025)). merge_level scalar. value (0,1) significance level construct credible sets merging. model component considered candidate merging merge_level-level credible set contains fewer detect indices. max_iter integer. Maximum number variational iterations. ELBO converge max_iter reached, converged == FALSE returned fit object. verbose logical. verbose == TRUE L_auto == FALSE, K_auto == FALSE, J_auto == FALSE value ELBO printed every 5000th iteration. verbose == TRUE L_auto, K_auto, J_auto TRUE, value ELBO printed combinatin \\((L,K,J)\\) mich_vector() searches parameterization maximized EBLO. reverse logical. reverse == TRUE MICH fit \\(\\mathbf{y}_{T:1}\\) model parameters reversed post-processing. restart logical. restart == TRUE L_auto, K_auto, J_auto TRUE, n_search increments L, K, /J, ELBO increased, mich_vector() restart setting L, K, J components null model initialization (except components maximum posterior probabilities > 0.9) refit begin search . increment integer. Number components increment L, K J L_auto, K_auto, J_auto TRUE. omega_j, u_j, v_j Scalars. Prior precision, shape, rate parameters meanvar-scp components model. pi_j character numeric vector matrix. Prior meanvar-scp model components. Must either length \\(T\\) vector entries sum one, \\(T \\times J\\) matrix columns sum one, character equal \"weighted\" \"uniform\". pi_j vector J > 1, pi_j used prior J meanvar-scp components model. pi_j == \"uniform\" uniform prior \\(\\pi_{jt} = 1/T\\) used components. pi_j == \"weighted\" log_meanvar_prior() used calculate weighted prior described Appendix C.2 Berlind, Cappello, Madrid Padilla (2025). J_auto == TRUE must case pi_j %% c(\"uniform\", \"weighted\"). omega_l scalar. Prior precision parameter mean-scp components model. y matrix prior precision \\(\\omega_\\ell\\mathbf{}_d\\). pi_l character numeric vector matrix. Prior mean-scp model components. Must either length \\(T\\) vector entries sum one, \\(T \\times L\\) matrix columns sum one, character equal \"weighted\" \"uniform\". pi_l vector L > 1, pi_l used prior L mean-scp components. pi_l == \"uniform\" uniform prior \\(\\pi_{\\ell t} = 1/T\\) used components. pi_l == \"weighted\" log_mean_prior() used calculate weighted prior described Appendix C.2 Berlind, Cappello, Madrid Padilla (2025). L_auto == TRUE must case pi_l %% c(\"uniform\", \"weighted\"). u_k, v_k Scalar. Prior shape rate parameters var-scp components model. pi_k character numeric vector matrix. Prior var-scp model components. Must either length \\(T\\) vector entries sum one, \\(T \\times K\\) matrix columns sum one, character equal \"weighted\" \"uniform\". pi_k vector K > 1, pi_k used prior K var-scp components. pi_k == \"uniform\" uniform prior \\(\\pi_{k t} = 1/T\\) used components. pi_k == \"weighted\" log_var_prior() used calculate weighted prior described Appendix C.2 Berlind, Cappello, Madrid Padilla (2025). K_auto == TRUE must case pi_k %% c(\"uniform\", \"weighted\").","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiple Independent Change-Point (MICH) Model ‚Äî mich","text":"list. Parameters variational approximation MICH posterior distribution. y vector, list includes: y: numeric vector. Original data. L,K,J: Integers. Number mean-scp, var-scp, meanvar-scp components included model. residual: numeric vector. Residual \\(\\tilde{\\mathbf{r}}_{1:T}\\) (see (B.4) Berlind, Cappello, Madrid Padilla (2025)). mu: numeric vector. Posterior estimate \\(\\Sigma_{\\ell=1}^L E[\\boldsymbol{\\mu}_{\\ell,1:T}|\\mathbf{y}_{1:T}] + \\Sigma_{j=1}^J E[\\boldsymbol{\\mu}_{j,1:T}|\\mathbf{y}_{1:T}]\\). lambda: numeric vector. Posterior estimate \\(\\Pi_{k=1}^K E[\\boldsymbol{\\lambda}_{k,1:T}|\\mathbf{y}_{1:T}] \\times \\Pi_{j=1}^J E[\\boldsymbol{\\lambda}_{j,1:T}|\\mathbf{y}_{1:T}]\\). delta: numeric vector. Posterior estimate equation (B.4) Berlind, Cappello, Madrid Padilla (2025). mu_0: scalar. Estimate intercept. lambda_0: scalar. Estimate initial precision. elbo: numeric vector. Value ELBO iteration. converged: logical. Indicates whether relative increase ELBO less tol. meanvar_model: list. List meanvar-scp posterior parameters: pi_bar: numeric matrix. \\(T \\times J\\) matrix posterior change-point location probabilities. b_bar: numeric matrix. \\(T \\times J\\) matrix posterior mean parameters. omega_bar: numeric matrix. \\(T \\times J\\) matrix posterior precision parameters. v_bar: numeric matrix. \\(T \\times J\\) matrix posterior rate parameters. u_bar: numeric vector. length \\(T\\) vector posterior shape parameters. mu_lambda_bar: numeric matrix. \\(T \\times J\\) matrix scaled posterior mean signals \\(E[\\lambda_{jt}\\mu_{jt}|\\mathbf{y}_{1:T}]\\). mu2_lambda_bar: numeric matrix. \\(T \\times J\\) matrix scaled posterior squared mean signals \\(E[\\lambda_{jt}\\mu^2_{jt}|\\mathbf{y}_{1:T}]\\). lambda_bar: numeric matrix. \\(T \\times J\\) matrix posterior precision signals \\(E[\\lambda_{jt}|\\mathbf{y}_{1:T}]\\). mean_model: list. List mean-scp posterior parameters: pi_bar: numeric matrix. \\(T \\times L\\) matrix posterior change-point location probabilities. b_bar: numeric matrix. \\(T \\times L\\) matrix posterior mean parameters. omega_bar: numeric matrix. \\(T \\times L\\) matrix posterior precision parameters. mu_bar: numeric matrix. \\(T \\times L\\) matrix posterior mean signals \\(E[\\mu_{\\ell t}|\\mathbf{y}_{1:T}]\\). mu2_bar: numeric matrix. \\(T \\times L\\) matrix posterior squared mean signals \\(E[\\mu_{\\ell t}^2|\\mathbf{y}_{1:T}]\\). var_model: list. List var-scp posterior parameters: pi_bar: numeric matrix. \\(T \\times K\\) matrix posterior change-point location probabilities. v_bar: numeric matrix. \\(T \\times K\\) matrix posterior rate parameters. u_bar: numeric vector. length \\(T\\) vector posterior shape parameters. lambda_bar: numeric matrix. \\(T \\times K\\) matrix posterior precision signals \\(E[\\lambda_{kt}|\\mathbf{y}_{1:T}]\\). y vector, list includes: y: numeric matrix. Original data. Sigma: numeric matrix. Estimate \\(\\Lambda^{-1}\\) fit_scale == TRUE. L: integer. Number components included model. pi_bar: numeric matrix.  \\(T \\times L\\) matrix posterior change-point location probabilites. residual: numeric matrix. Residual \\(\\mathbf{r}_{1:T}\\) subtracting \\(E[\\boldsymbol{\\mu}_{\\ell t}]\\) \\(\\mathbf{y}_{1:T}\\). mu: numeric matrix. Posterior estimate \\(\\Sigma_{\\ell=1}^L E[\\boldsymbol{\\mu}_{\\ell,1:T}|\\mathbf{y}_{1:T}]\\). mu_0: numeric vector. Estimate intercept. post_params: list. List posterior parameters mean-scp component. elbo: numeric vector. Value ELBO iteration. converged: logical. Indicates whether relative increase ELBO less tol.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiple Independent Change-Point (MICH) Model ‚Äî mich","text":"","code":"set.seed(222) # generate univariate data with two mean-variance change-points y = c(rnorm(100,0,10), rnorm(100,10,3), rnorm(100,0,6)) fit = mich(y, J = 2) # fit two mean-variance change-points # plot change-points with 95% credible sets plot(fit, level = 0.95, cs = TRUE)  # fit one mean and one mean-variance change-point fit = mich(y, J = 1, L = 1) # plot change-points with 95% credible sets and signal plot(fit, level = 0.95, cs = TRUE, signal = TRUE)   # generate correlated mulitvariate data with two mean-variance change-points T <- 150 Sigma <- rbind(c(1, 0.7), c(0.7, 2)) d <- ncol(Sigma) Sigma_eigen <- eigen(Sigma) e_vectors <- Sigma_eigen$vectors e_values <- Sigma_eigen$values Sigma_sd <- e_vectors %*% diag(sqrt(e_values)) %*% t(e_vectors) Z <- sapply(1:d, function(i) rnorm(T)) mu <- c(-1, 2) mu_t <- matrix(0, nrow = 70, ncol=d) mu_t <- rbind(mu_t, t(sapply(1:30, function(i) mu))) mu_t <- rbind(mu_t, matrix(0, nrow = 50, ncol = d)) Y <- mu_t + Z %*% Sigma_sd # fit MICH and pick L automatically using ELBO fit = mich(Y, L_auto = TRUE) plot(fit, level = 0.95, cs = TRUE, signal = TRUE)"},{"path":"https://davis-berlind.github.io/mich/reference/mich_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"MICH Algorithm ‚Äî mich_cpp","title":"MICH Algorithm ‚Äî mich_cpp","text":"Implementation Algorithms 1 & 2 Berlind, Cappello, Madrid Padilla (2025). algorithm takes sequence \\(T\\) observations \\(\\mathbf{y}_{1:T}\\), iteratively fits \\(L\\) mean-scp models, \\(K\\) var-scp models, \\(J\\) meanvar-scp models resulting variational approximation posterior distribution \\(L\\) mean, \\(K\\) variance, \\(J\\) mean variance change-points. algorithm terminates percentage increase ELBO falls tol.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MICH Algorithm ‚Äî mich_cpp","text":"","code":"mich_cpp(   y,   J,   L,   K,   mu_0,   lambda_0,   fit_intercept,   fit_scale,   refit,   max_iter,   verbose,   tol,   omega_j,   u_j,   v_j,   log_pi_j,   pi_bar_j,   log_pi_bar_j,   b_bar_j,   omega_bar_j,   u_bar_j,   v_bar_j,   lgamma_u_bar_j,   digamma_u_bar_j,   omega_l,   log_pi_l,   pi_bar_l,   log_pi_bar_l,   b_bar_l,   omega_bar_l,   u_k,   v_k,   log_pi_k,   pi_bar_k,   log_pi_bar_k,   u_bar_k,   v_bar_k,   lgamma_u_bar_k,   digamma_u_bar_k )"},{"path":"https://davis-berlind.github.io/mich/reference/mich_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MICH Algorithm ‚Äî mich_cpp","text":"y numeric vector. Length \\(T\\) vector observations. L, K, J Integers. number mean, variance, mean-variance change-points include model. mu_0 scalar. Intercept parameter initialization. lambda_0 scalar. Baseline scale parameter initialization. fit_intercept logical. fit_intercept == TRUE, intercept estimated mu_0 gets updated. fit_scale logical. fit_scale == TRUE, initial scale estimated lambda_0 gets updated. refit logical. refit == TRUE, MICH algorithm initialized using provided posterior parameters, otherwise null model \\(\\mu_t = 0\\), \\(\\lambda_t = 1\\) \\(\\bar{\\pi}_{\\ell t} = \\bar{\\pi}_{k t} = \\bar{\\pi}_{j t}  = 1/T\\) used initialization. max_iter integer. Maximum number iterations. ELBO converge max_iter reached, converged == FALSE returned fit object. verbose logical. verbose == TRUE, value ELBO printed every 5000th iteration. tol scalar. Convergence tolerance relative increase ELBO. omega_j, u_j, v_j Scalars. Prior precision, shape, rate parameters meanvar-scp components model. log_pi_j numeric matrix. \\(T \\times J\\) matrix prior log change-point location probabilities \\(J\\) mean-variance change-points. pi_bar_j, log_pi_bar_j Numeric matrices. \\(T \\times J\\) matrices initialized posterior change-point location probabilities log evaluations \\(J\\) mean-variance change-points. b_bar_j numeric matrix. \\(T \\times J\\) matrix initialized posterior mean parameters \\(J\\) mean-variance change-points. omega_bar_j numeric matrix. \\(T\\times J\\) matrix initialized posterior precision parameters \\(J\\) mean-variance change-points. u_bar_j, lgamma_u_bar_j, digamma_u_bar_j Numeric vectors. Length \\(T\\) vectors posterior shape parameters meanvar-scp model components log-gamma digamma evaluations. v_bar_j numeric matrix. \\(T \\times J\\) matrix initialized posterior rate parameters \\(J\\) mean-variance change-points. omega_l scalar. Prior precision parameter mean-scp components model. log_pi_l numeric matrix. \\(T \\times L\\) matrix prior log change-point location probabilities \\(L\\) mean change-points. pi_bar_l, log_pi_bar_l Numeric matrices. \\(T \\times L\\) matrices initialized posterior change-point location probabilities log evaluations \\(L\\) mean change-points. b_bar_l numeric matrix. \\(T \\times L\\) matrix initialized posterior mean parameters \\(L\\) mean change-points. omega_bar_l numeric matrix. \\(T\\times L\\) matrix initialized posterior precision parameters \\(L\\) mean change-points. u_k, v_k Scalars. Prior shape rate parameters var-scp components model. log_pi_k numeric matrix. \\(T \\times K\\) matrix prior log change-point location probabilities \\(K\\) variance change-points. pi_bar_k, log_pi_bar_k Numeric matrices. \\(T \\times K\\) matrices initialized posterior change-point location probabilities log evaluations \\(K\\) variance change-points. u_bar_k, lgamma_u_bar_k, digamma_u_bar_k Numeric vectors. Length \\(T\\) vectors posterior shape parameters var-scp model components log-gamma digamma evaluations. v_bar_k numeric matrix. \\(T \\times K\\) matrix initialized posterior rate parameters \\(K\\) variance change-points.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MICH Algorithm ‚Äî mich_cpp","text":"List. Parameters variational approximation MICH posterior distribution, including: y: numeric vector. Original data set. residual: numeric vector. Residual \\(\\mathbf{r}_{1:T}\\) subtracting \\(E[\\mu_{\\ell t}]\\) \\(E[\\lambda_{j t} \\mu_{j t}]/E[\\lambda_{j t}]\\) \\(\\mathbf{y}_{1:T}\\). mu: numeric vector. Posterior estimate \\(\\Sigma_{\\ell=1}^L E[\\mu_{\\ell,1:T}|\\mathbf{y}_{1:T}] + \\Sigma_{j=1}^J E[\\mu_{j,1:T}|\\mathbf{y}_{1:T}]\\). lambda: numeric vector. Posterior estimate \\(\\Pi_{\\\\k=1}^K E[\\lambda_{k,1:T}|\\mathbf{y}_{1:T}] \\times \\Pi_{j=1}^J E[\\lambda_{j,1:T}|\\mathbf{y}_{1:T}]\\). delta: numeric vector. Posterior variance correction term (see (B.6) Berlind, Cappello, Madrid Padilla (2025)). converged: logical. Indicates whether relative increase ELBO less tol. elbo: numeric vector. Value ELBO iteration. mu_0: scalar. Estimate intercept. lambda_0: scalar. Estimate initial precision. J, L, K: Integers. number mean, variance, mean-variance components. J_model: list. list posterior parameters \\(J\\) meanvar-scp components (included J > 0). L_model: list. list posterior parameters \\(L\\) mean-scp components (included L > 0). K_model: list. list posterior parameters \\(K\\) var-scp components (included K > 0).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate Multiple Independent Change-Point (MICH) Model ‚Äî mich_matrix","title":"Multivariate Multiple Independent Change-Point (MICH) Model ‚Äî mich_matrix","text":"Fits multivariate version MICH model mean change-points. Number change-points can either fixed mich_matrix() search number changes maximizes ELBO L_auto == TRUE.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate Multiple Independent Change-Point (MICH) Model ‚Äî mich_matrix","text":"","code":"mich_matrix(   y,   fit_intercept,   fit_scale,   standardize,   L,   L_auto,   L_max,   pi_l_weighted,   tol,   verbose,   max_iter,   reverse,   detect,   merge_level,   merge_prob,   restart,   n_search,   increment,   omega_l,   log_pi_l )"},{"path":"https://davis-berlind.github.io/mich/reference/mich_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate Multiple Independent Change-Point (MICH) Model ‚Äî mich_matrix","text":"y numeric matrix. \\(T \\times d\\) matrix observations. fit_intercept logical. fit_intercept == TRUE, intercept estimated, otherwise assumed  \\(\\boldsymbol{\\mu}_0 = \\mathbf{0}\\). fit_scale logical. fit_scale == TRUE, precision matrix \\(\\Lambda = E[\\mathbf{y}_t\\mathbf{y}'_t]^{-1}\\) estimated using \\(\\hat{\\Lambda}^{-1} = \\frac{1}{2(T-1)} \\Sigma_{t=1}^{T-1} (\\mathbf{y}_{t+1} - \\mathbf{y}_{t})(\\mathbf{y}_{t+1} - \\mathbf{y}_{t})'\\), otherwise assumed \\(\\Lambda = \\mathbf{}_d\\). standardize logical. standardize == TRUE, y centered rescaled fitting. L integer. Number mean-scp components included model. L_auto == TRUE L lower bounds number change-points model. L_auto logical. L_auto == TRUE, mich_matrix() returns \\(L\\) L L_max maximizes ELBO (see Appendix C.4 Berlind, Cappello, Madrid Padilla (2025)). L_max L integer. L_auto == TRUE L_max upper bounds number change-points included model. pi_l_weighted logical. pi_l_weighted == TRUE, weighted priors specified Appendix C.2 Berlind, Cappello, Madrid Padilla (2025) used. tol scalar. Convergence tolerance relative increase ELBO. verbose logical. verbose == TRUE L_auto == FALSE, value ELBO printed every 5000th iteration. verbose == TRUE L_auto == TRUE, value ELBO printed \\(L\\) mich_matrix() searches [L, L_max]. max_iter integer. Maximum number iterations. ELBO converge max_iter reached, converged == FALSE returned fit object. reverse logical. reverse == TRUE MICH fit \\(\\mathbf{y}_{T:1}\\) model parameters reversed post-processing. detect scalar. detection criteria. \\(\\ell^{\\text{th}}\\) component model detects change-point posterior credible set component contains fewer detect indices. merge_level scalar. value (0,1) significance level construct credible sets merging. model component considered candidate merging merge_level-level credible set contains fewer detect indices. merge_prob scalar. value (0,1) indicating merge criterion. posterior probability two components identify change greater merge_level, components merged (see Appendix C.3 Berlind, Cappello, Madrid Padilla (2025)). restart logical. restart == TRUE L_auto == TRUE n_search increments L, ELBO increased, mich_matrix() restart setting L components null model initialization (except components maximum posterior probabilities > 0.9) refit begin search . n_search integer. Grid search parameter. Number times increment L terminating automatic procedure L_auto == TRUE. increment integer. Number components increment L L_auto == TRUE. omega_l scalar. Prior precision parameter mean-scp components model. log_pi_l numeric matrix. \\(T \\times L\\) matrix prior log change-point location probabilities \\(L\\) mean change-points.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate Multiple Independent Change-Point (MICH) Model ‚Äî mich_matrix","text":"list. Parameters variational approximation MICH posterior distribution, including: y: numeric matrix. Original data. Sigma: numeric matrix. Estimate \\(\\Lambda^{-1}\\) fit_scale == TRUE. L: integer. Number components included model. pi_bar: numeric matrix.  \\(T \\times L\\) matrix posterior change-point location probabilites. residual: numeric matrix. Residual \\(\\mathbf{r}_{1:T}\\) subtracting \\(E[\\boldsymbol{\\mu}_{\\ell t}]\\) \\(\\mathbf{y}_{1:T}\\). mu: numeric matrix. Posterior estimate \\(\\Sigma_{\\ell=1}^L E[\\boldsymbol{\\mu}_{\\ell,1:T}|\\mathbf{y}_{1:T}]\\). mu_0: numeric vector. Estimate intercept. post_params: list. List posterior parameters mean-scp component. elbo: numeric vector. Value ELBO iteration. converged: logical. Indicates whether relative increase ELBO less tol.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_sets.html","id":null,"dir":"Reference","previous_headings":"","what":"MICH Posterior Credible Sets ‚Äî mich_sets","title":"MICH Posterior Credible Sets ‚Äî mich_sets","text":"function mich_sets() takes \\(T \\times N\\) matrix posterior change-point location probabilities \\(\\{\\pi_{,1:T}\\}_{=1}^N\\), coverage level \\(\\alpha\\), max set length, \\(1\\leq \\leq N\\) returns MAP estimator \\(\\arg\\max_{1\\leq t \\leq T} \\pi_{}\\) smallest set \\(S_i\\) \\(\\Sigma_{t \\S_i} \\pi_{} \\geq \\alpha\\) \\(|S_i|<\\) max_length.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_sets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MICH Posterior Credible Sets ‚Äî mich_sets","text":"","code":"mich_sets(probs, max_length = log(nrow(probs))^1.5, level = 0.9)"},{"path":"https://davis-berlind.github.io/mich/reference/mich_sets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MICH Posterior Credible Sets ‚Äî mich_sets","text":"probs numeric Matrix. \\(T \\times N\\) matrix posterior probabilities location change-points. max_length positive scalar. Detection threshold, credible set contains max_length indices, change detected. Set equal \\(\\log^{1.5} T\\) default (see Section 2.5 Berlind, Cappello, Madrid Padilla (2025)). level scalar. single number (0,1) gives lower bound probability credible set contains change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_sets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MICH Posterior Credible Sets ‚Äî mich_sets","text":"list. MAP estimator change-point corresponding credible set.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate Multiple Independent Change-Point (MICH) Model ‚Äî mich_vector","title":"Univariate Multiple Independent Change-Point (MICH) Model ‚Äî mich_vector","text":"Fits univariate version MICH model mean variance change-points. Number change-points can either fixed mich_vector() search number changes maximizes ELBO (L_auto | K_auto | J_auto) == TRUE.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate Multiple Independent Change-Point (MICH) Model ‚Äî mich_vector","text":"","code":"mich_vector(   y,   fit_intercept,   fit_scale,   standardize,   J,   L,   K,   J_auto,   L_auto,   K_auto,   J_max,   L_max,   K_max,   pi_j_weighted,   pi_l_weighted,   pi_k_weighted,   tol,   verbose,   max_iter,   reverse,   detect,   merge_level,   merge_prob,   restart,   n_search,   increment,   omega_j,   u_j,   v_j,   log_pi_j,   omega_l,   log_pi_l,   u_k,   v_k,   log_pi_k )"},{"path":"https://davis-berlind.github.io/mich/reference/mich_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate Multiple Independent Change-Point (MICH) Model ‚Äî mich_vector","text":"y numeric vector. Length \\(T\\) vector observations. fit_intercept logical. fit_intercept == TRUE, intercept estimated, otherwise assumed  \\(\\mu_0 = 0\\). fit_scale logical. fit_scale == TRUE, initial precision estimated, otherwise assumed  \\(\\lambda_0 = 1\\). standardize logical. standardize == TRUE, y centered rescaled fitting. L, K, J Integers. Respective number mean-scp, var-scp, meanvar-scp components included model. L_auto == TRUE, K_auto == TRUE, J_auto == TRUE L, K, J lower bound number kind change-point model. L_auto, K_auto, J_auto Logicals. L_auto == TRUE, K_auto == TRUE, /J_auto == TRUE, mich_vector() returns \\(L\\) L L_max, \\(K\\) K K_max, /\\(J\\) J J_max maximize ELBO (see Appendix C.4 Berlind, Cappello, Madrid Padilla (2025)). L_max, K_max, J_max Integers. L_auto == TRUE, K_auto == TRUE, J_auto == TRUE L_max, K_max, J_max upper bound number kind change-point model. pi_l_weighted, pi_k_weighted, pi_j_weighted Logicals. TRUE, weighted priors specified Appendix C.2 Berlind, Cappello, Madrid Padilla (2025) used. tol scalar. Convergence tolerance relative increase ELBO. verbose logical. verbose == TRUE L_auto == FALSE, K_auto == FALSE, J_auto == FALSE value ELBO printed every 5000th iteration. verbose == TRUE L_auto, K_auto, J_auto TRUE, value ELBO printed combinatin \\((L,K,J)\\) mich_vector() searches parameterization maximized EBLO. max_iter integer. Maximum number iterations. ELBO converge max_iter reached, converged == FALSE returned fit object. reverse logical. reverse == TRUE MICH fit \\(\\mathbf{y}_{T:1}\\) model parameters reversed post-processing. detect scalar. detection criteria. \\(^{\\text{th}}\\) component model detects change-point posterior credible set component contains fewer detect indices. merge_level scalar. value (0,1) significance level construct credible sets merging. model component considered candidate merging merge_level-level credible set contains fewer detect indices. merge_prob scalar. value (0,1) indicating merge criterion. posterior probability two components identify change greater merge_level, components merged (see Appendix C.3 Berlind, Cappello, Madrid Padilla (2025)). restart logical. restart == TRUE L_auto, K_auto, J_auto TRUE, n_search increments L, K, /J, ELBO increased, mich_vector() restart setting L, K, J components null model initialization (except components maximum posterior probabilities > 0.9) refit begin search . n_search integer. Grid search parameter. Number times increment L, K, /J terminating automatic procedure L_auto, K_auto, J_auto TRUE. increment integer. Number components increment L, K J L_auto, K_auto, J_auto TRUE. omega_j scalar. Prior precision parameter meanvar-scp components model. u_j scalar. Prior shape parameter meanvar-scp components model. v_j scalar. Prior rate parameter meanvar-scp components model. log_pi_j numeric matrix. \\(T \\times J\\) matrix prior log change-point location probabilities \\(J\\) mean-variance change-points. omega_l scalar. Prior precision parameter mean-scp components model. log_pi_l numeric matrix. \\(T \\times L\\) matrix prior log change-point location probabilities \\(L\\) mean change-points. u_k scalar. Prior shape parameter var-scp components model. v_k scalar. Prior rate parameter var-scp components model. log_pi_k numeric matrix. \\(T \\times K\\) matrix prior log change-point location probabilities \\(K\\) variance change-points.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate Multiple Independent Change-Point (MICH) Model ‚Äî mich_vector","text":"list. Parameters variational approximation MICH posterior distribution, including: y: numeric vector. Original data. L,K,J: Integers. Number mean-scp, var-scp, meanvar-scp components included model. residual: numeric vector. Residual \\(\\tilde{\\mathbf{r}}_{1:T}\\) (see (B.4) Berlind, Cappello, Madrid Padilla (2025)). mu: numeric vector. Posterior estimate \\(\\Sigma_{\\ell=1}^L E[\\boldsymbol{\\mu}_{\\ell,1:T}|\\mathbf{y}_{1:T}] + \\Sigma_{j=1}^J E[\\boldsymbol{\\mu}_{j,1:T}|\\mathbf{y}_{1:T}]\\). lambda: numeric vector. Posterior estimate \\(\\Pi_{k=1}^K E[\\boldsymbol{\\lambda}_{k,1:T}|\\mathbf{y}_{1:T}] \\times \\Pi_{j=1}^J E[\\boldsymbol{\\lambda}_{j,1:T}|\\mathbf{y}_{1:T}]\\). delta: numeric vector. Posterior estimate equation (B.4) Berlind, Cappello, Madrid Padilla (2025). mu_0: scalar. Estimate intercept. lambda_0: scalar. Estimate initial precision. elbo: numeric vector. Value ELBO iteration. converged: logical. Indicates whether relative increase ELBO less tol. meanvar_model: list. List meanvar-scp posterior parameters: pi_bar: numeric matrix. \\(T \\times J\\) matrix posterior change-point location probabilities. b_bar: numeric matrix. \\(T \\times J\\) matrix posterior mean parameters. omega_bar: numeric matrix. \\(T \\times J\\) matrix posterior precision parameters. v_bar: numeric matrix. \\(T \\times J\\) matrix posterior rate parameters. u_bar: numeric vector. length \\(T\\) vector posterior shape parameters. mu_lambda_bar: numeric matrix. \\(T \\times J\\) matrix scaled posterior mean signals \\(E[\\lambda_{jt}\\mu_{jt}|\\mathbf{y}_{1:T}]\\). mu2_lambda_bar: numeric matrix. \\(T \\times J\\) matrix scaled posterior squared mean signals \\(E[\\lambda_{jt}\\mu^2_{jt}|\\mathbf{y}_{1:T}]\\). lambda_bar: numeric matrix. \\(T \\times J\\) matrix posterior precision signals \\(E[\\lambda_{jt}|\\mathbf{y}_{1:T}]\\). mean_model: list. List mean-scp posterior parameters: pi_bar: numeric matrix. \\(T \\times L\\) matrix posterior change-point location probabilities. b_bar: numeric matrix. \\(T \\times L\\) matrix posterior mean parameters. omega_bar: numeric matrix. \\(T \\times L\\) matrix posterior precision parameters. mu_bar: numeric matrix. \\(T \\times L\\) matrix posterior mean signals \\(E[\\mu_{\\ell t}|\\mathbf{y}_{1:T}]\\). mu2_bar: numeric matrix. \\(T \\times L\\) matrix posterior squared mean signals \\(E[\\mu_{\\ell t}^2|\\mathbf{y}_{1:T}]\\). var_model: list. List var-scp posterior parameters: pi_bar: numeric matrix. \\(T \\times K\\) matrix posterior change-point location probabilities. v_bar: numeric matrix. \\(T \\times K\\) matrix posterior rate parameters. u_bar: numeric vector. length \\(T\\) vector posterior shape parameters. lambda_bar: numeric matrix. \\(T \\times K\\) matrix posterior precision signals \\(E[\\lambda_{kt}|\\mathbf{y}_{1:T}]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu2_bar_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected Squared-Mean Signal ‚Äî mu2_bar_fn","title":"Expected Squared-Mean Signal ‚Äî mu2_bar_fn","text":"Given \\(E[y_t|b,\\tau]=\\mu_t=bI(t\\geq \\tau)\\), \\(P(\\tau=t)=\\pi_t\\), \\(\\bar{b}_t=E[b|\\tau=t]\\), \\(\\bar{\\omega}_t=V(b|\\tau=t)\\), mu2_bar_fn() calculates \\(E[\\mu^2_t]\\) \\(\\Sigma_{t'=1}^t (\\bar{b}^2_{t'} + 1 / \\bar{\\omega}_{t'})\\pi_{t'}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu2_bar_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected Squared-Mean Signal ‚Äî mu2_bar_fn","text":"","code":"mu2_bar_fn(b, omega, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/mu2_bar_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected Squared-Mean Signal ‚Äî mu2_bar_fn","text":"b numeric vector. Length \\(T\\) vector conditional mean parameters. omega numeric vector. Length \\(T\\) vector conditional variance parameters. prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu2_bar_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected Squared-Mean Signal ‚Äî mu2_bar_fn","text":"numeric vector. length \\(T\\) vector \\(E[\\mu_t]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu2_lambda_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected Squared-Mean-Precision Signal ‚Äî mu2_lambda_fn","title":"Expected Squared-Mean-Precision Signal ‚Äî mu2_lambda_fn","text":"Given \\(E[y_t|b,\\tau]=\\mu_t=bI(t\\geq \\tau)\\), \\(\\bar{b}_t=E[b|\\tau=t]\\), \\(V(y_t|s,\\tau)=1/\\lambda_t=1/s^{(t\\geq \\tau)}\\), \\(\\bar{u}_t/\\bar{v}_t=E[s|\\tau=t]\\), \\(P(\\tau=t)=\\pi_t\\), mu_lambda_fn() calculates \\(E[\\mu^2_t\\lambda_t]\\) \\(\\Sigma_{t'=1}^t \\pi_{t'}(\\bar{b}^2_{t'}\\bar{v}_{t'} / \\bar{u}_{t'} + 1/\\bar{\\omega}_{t'})\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu2_lambda_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected Squared-Mean-Precision Signal ‚Äî mu2_lambda_fn","text":"","code":"mu2_lambda_fn(b, omega, u, v, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/mu2_lambda_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected Squared-Mean-Precision Signal ‚Äî mu2_lambda_fn","text":"b numeric vector. Length \\(T\\) vector conditional mean parameters. omega numeric vector. Length \\(T\\) vector conditional variance parameters. u numeric vector. Length \\(T\\) vector conditional shape parameters v numeric vector. Length \\(T\\) vector conditional rate parameters prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu2_lambda_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected Squared-Mean-Precision Signal ‚Äî mu2_lambda_fn","text":"numeric vector. length \\(T\\) vector \\(E[\\mu^2_t\\lambda_t]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu_bar_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected Mean Signal ‚Äî mu_bar_fn","title":"Expected Mean Signal ‚Äî mu_bar_fn","text":"Given \\(E[y_t|b,\\tau]=\\mu_t=bI(t\\geq \\tau)\\), \\(P(\\tau=t)=\\pi_t\\), \\(\\bar{b}_t=E[b|\\tau=t]\\), mu_bar_fn() calculates \\(E[\\mu_t]\\) \\(\\Sigma_{t'=1}^t \\bar{b}_{t'}\\pi_{t'}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu_bar_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected Mean Signal ‚Äî mu_bar_fn","text":"","code":"mu_bar_fn(b, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/mu_bar_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected Mean Signal ‚Äî mu_bar_fn","text":"b numeric vector. Length \\(T\\) vector conditional mean parameters. prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu_bar_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected Mean Signal ‚Äî mu_bar_fn","text":"numeric vector. length \\(T\\) vector \\(E[\\mu_t]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu_lambda_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected Mean-Precision Signal ‚Äî mu_lambda_fn","title":"Expected Mean-Precision Signal ‚Äî mu_lambda_fn","text":"Given \\(E[y_t|b,\\tau]=\\mu_t=bI(t\\geq \\tau)\\), \\(\\bar{b}_t=E[b|\\tau=t]\\), \\(\\bar{\\omega}_t=V(b|\\tau=t)\\), \\(V(y_t|s,\\tau)=1/\\lambda_t=1/s^{(t\\geq \\tau)}\\), \\(\\bar{u}_t/\\bar{v}_t=E[s|\\tau=t]\\), \\(P(\\tau=t)=\\pi_t\\), mu_lambda_fn() calculates \\(E[\\mu_t\\lambda_t]\\) \\(\\Sigma_{t'=1}^t \\bar{b}_{t'}\\bar{v}_{t'} \\pi_{t'}/ \\bar{u}_{t'}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu_lambda_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected Mean-Precision Signal ‚Äî mu_lambda_fn","text":"","code":"mu_lambda_fn(b, u, v, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/mu_lambda_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected Mean-Precision Signal ‚Äî mu_lambda_fn","text":"b numeric vector. Length \\(T\\) vector conditional mean parameters. u numeric vector. Length \\(T\\) vector conditional shape parameters v numeric vector. Length \\(T\\) vector conditional rate parameters prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu_lambda_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected Mean-Precision Signal ‚Äî mu_lambda_fn","text":"numeric vector. length \\(T\\) vector \\(E[\\mu_t\\lambda_t]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mean_scp.html","id":null,"dir":"Reference","previous_headings":"","what":"Mulitvariate Mean Single Change-Point Model ‚Äî multi_mean_scp","title":"Mulitvariate Mean Single Change-Point Model ‚Äî multi_mean_scp","text":"Implementation multivariate Mean-SCP model Berlind, Cappello, Madrid Padilla (2025). function mean_scp() takes \\(T\\times d\\) matrix \\(\\mathbf{y}_{1:T}\\) single mean change returns posterior distribution change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mean_scp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mulitvariate Mean Single Change-Point Model ‚Äî multi_mean_scp","text":"","code":"multi_mean_scp(y, omega_bar, log_omega_bar, log_pi)"},{"path":"https://davis-berlind.github.io/mich/reference/multi_mean_scp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mulitvariate Mean Single Change-Point Model ‚Äî multi_mean_scp","text":"y numeric matrix. \\(T\\times d\\) matrix observations single mean change. omega_bar numeric vector. Posterior precision parameters \\(\\bar{\\omega}_t\\) \\(\\bar{\\Omega}_t = \\bar{\\omega}_t\\mathbf{}_d\\). log_omega_bar numeric vector. Log omega_bar. log_pi numeric vector. Vector log prior probabilities location change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mean_scp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mulitvariate Mean Single Change-Point Model ‚Äî multi_mean_scp","text":"list. list posterior parameters including mean b_bar, posterior probabilities change-point location pi_bar.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mich_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate MICH Algorithm ‚Äî multi_mich_cpp","title":"Multivariate MICH Algorithm ‚Äî multi_mich_cpp","text":"Implementation Algorithm 3 Berlind, Cappello, Madrid Padilla (2025). algorithm takes sequence \\(d\\)-dimensional observations \\(\\mathbf{y}_{1:T}\\), iteratively fits \\(L\\) mean-scp models resulting variational approximation posterior distribution \\(L\\) mean change-points. algorithm terminates percentage increase ELBO falls tol.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mich_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate MICH Algorithm ‚Äî multi_mich_cpp","text":"","code":"multi_mich_cpp(   y,   mu_0,   fit_intercept,   refit,   max_iter,   tol,   verbose,   omega_l,   log_pi_l,   omega_bar_l,   log_omega_bar_l,   post_params )"},{"path":"https://davis-berlind.github.io/mich/reference/multi_mich_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate MICH Algorithm ‚Äî multi_mich_cpp","text":"y numeric matrix. \\(T \\times d\\) matrix observations. mu_0 numeric vector. Vector intercept parameters. fit_intercept logical. fit_intercept == TRUE, intercept estimated mu_0 gets updated. refit logical. refit == TRUE, MICH algorithm initialized fit provided post_params, otherwise null model \\(\\boldsymbol{\\mu}_t = \\mathbf{0}\\) \\(\\bar{\\pi}_{\\ell t} = 1/T\\) used initialization. max_iter integer. Maximum number iterations. ELBO converge max_iter reached, converged == FALSE returned fit object. tol scalar. Convergence tolerance relative increase ELBO. verbose logical. verbose == TRUE, value ELBO printed every 5000th iteration. omega_l scalar. Prior precision parameter mean-scp components model. log_pi_l numeric matrix. \\(T \\times L\\) matrix prior log change-point location probabilities \\(L\\) mean change-points. omega_bar_l, log_omega_bar_l Numeric vectors. Vector posterior precision parameters \\(\\{\\bar{\\omega}_t\\}_{t=1}^T\\) log evaluations \\(V(\\mathbf{b}_\\ell|\\tau=t) = \\bar{\\omega}_t\\mathbf{}_d\\). post_params list. length \\(L\\) list posterior parameters mean-scp component. element list list containing \\(T\\times L\\) matrix posterior mean parameters length \\(T\\) vectors posterior change-point location probabilities log evaluations.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mich_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate MICH Algorithm ‚Äî multi_mich_cpp","text":"List. Parameters variational approximation MICH posterior distribution, including: L: integer. Number components included model. residual: numeric matrix. Residual \\(\\mathbf{r}_{1:T}\\) subtracting \\(E[\\boldsymbol{\\mu}_{\\ell t}]\\) \\(\\mathbf{y}_{1:T}\\). mu: numeric matrix. Posterior estimate \\(\\Sigma_{\\ell=1}^L E[\\boldsymbol{\\mu}_{\\ell,1:T}|\\mathbf{y}_{1:T}]\\). mu_0: numeric vector. Estimate intercept. post_params: list. List posterior parameters mean-scp component. elbo: numeric vector. Value ELBO iteration. converged: logical. Indicates whether relative increase ELBO less tol.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu2_bar_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate Expected Squared-Mean Signal ‚Äî multi_mu2_bar_fn","title":"Multivariate Expected Squared-Mean Signal ‚Äî multi_mu2_bar_fn","text":"Given \\(E[\\mathbf{y}_t|\\mathbf{b},\\tau] = \\mathbf{b}(t\\geq \\tau)\\), \\(P(\\tau = t)=\\pi_t\\), \\(1\\leq \\leq d\\), \\(\\bar{b}_{}=E[b_i|\\tau=t]\\) \\(\\bar{\\omega}_{}=V(b_i|\\tau=t)\\), multi_mu2_bar_fn() calculates \\(E[b_i^2I(t\\geq \\tau)]\\) \\(\\Sigma_{t'=1}^t (\\bar{b}^2_{'} + 1/\\bar{\\omega}_{'}) \\pi_{t'}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu2_bar_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate Expected Squared-Mean Signal ‚Äî multi_mu2_bar_fn","text":"","code":"multi_mu2_bar_fn(b, omega, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu2_bar_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate Expected Squared-Mean Signal ‚Äî multi_mu2_bar_fn","text":"b numeric matrix. \\(T\\times d\\) matrix conditional mean parameters. omega numeric vector. Length \\(T\\) vector conditional variance parameters. prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu2_bar_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate Expected Squared-Mean Signal ‚Äî multi_mu2_bar_fn","text":"numeric matrix. \\(T\\times d\\) matrix \\(E[b^2_iI(t\\geq \\tau)]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu_bar_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate Expected Mean Signal ‚Äî multi_mu_bar_fn","title":"Multivariate Expected Mean Signal ‚Äî multi_mu_bar_fn","text":"Given \\(E[\\mathbf{y}_t|\\mathbf{b},\\tau] = \\mathbf{b}(t\\geq \\tau)\\), \\(P(\\tau = t)=\\pi_t\\), \\(\\bar{\\mathbf{b}}_t=E[\\mathbf{b}|\\tau=t]\\), multi_mu_bar_fn() calculates \\(E[\\mathbf{b}(t\\geq \\tau)]\\) \\(\\Sigma_{t'=1}^t \\bar{\\mathbf{b}}_{t'}\\pi_{t'}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu_bar_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate Expected Mean Signal ‚Äî multi_mu_bar_fn","text":"","code":"multi_mu_bar_fn(b, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu_bar_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate Expected Mean Signal ‚Äî multi_mu_bar_fn","text":"b numeric matrix. \\(T\\times d\\) matrix conditional mean parameters. prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu_bar_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate Expected Mean Signal ‚Äî multi_mu_bar_fn","text":"numeric matrix. \\(T\\times d\\) matrix \\(E[\\mathbf{b}(t\\geq \\tau)]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/plot.mich.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for mich.fit objects ‚Äî plot.mich.fit","title":"Plot method for mich.fit objects ‚Äî plot.mich.fit","text":"Plots resulting fit estimated change-points calling mich().","code":""},{"path":"https://davis-berlind.github.io/mich/reference/plot.mich.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for mich.fit objects ‚Äî plot.mich.fit","text":"","code":"# S3 method for class 'mich.fit' plot(   x,   level = 0.95,   max_length = NULL,   signal = FALSE,   cs = TRUE,   n_plots = 5,   ... )"},{"path":"https://davis-berlind.github.io/mich/reference/plot.mich.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for mich.fit objects ‚Äî plot.mich.fit","text":"x mich.fit object. Output running mich() numeric vector matrix. level scalar. number (0,1) indicating significance level construct credible sets cs == TRUE. max_length integer. Detection threshold, see mich_sets(). Equal \\(\\log^{2}(T)\\) default. signal logical. TRUE, posterior mean precision signals also plotted. cs logical. TRUE, level-level credible sets detected change-point also plotted. n_plots integer. Number plot display data y matrix. ... Additional arguments passed methods.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/plot.mich.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for mich.fit objects ‚Äî plot.mich.fit","text":"Invisibly returns NULL.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/plot.mich.fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot method for mich.fit objects ‚Äî plot.mich.fit","text":"","code":"set.seed(222) # generate univariate data with two mean-variance change-points y = c(rnorm(100,0,10), rnorm(100,10,3), rnorm(100,0,6)) fit = mich(y, J = 2) # fit two mean-variance change-points # plot change-points with 95% credible sets plot(fit, level = 0.95, cs = TRUE)  # fit one mean and one mean-variance change-point fit = mich(y, J = 1, L = 1) # plot change-points with 95% credible sets and signal plot(fit, level = 0.95, cs = TRUE, signal = TRUE)   # generate correlated mulitvariate data with two mean-variance change-points T <- 150 Sigma <- rbind(c(1, 0.7), c(0.7, 2)) d <- ncol(Sigma) Sigma_eigen <- eigen(Sigma) e_vectors <- Sigma_eigen$vectors e_values <- Sigma_eigen$values Sigma_sd <- e_vectors %*% diag(sqrt(e_values)) %*% t(e_vectors) Z <- sapply(1:d, function(i) rnorm(T)) mu <- c(-1, 2) mu_t <- matrix(0, nrow = 70, ncol=d) mu_t <- rbind(mu_t, t(sapply(1:30, function(i) mu))) mu_t <- rbind(mu_t, matrix(0, nrow = 50, ncol = d)) Y <- mu_t + Z %*% Sigma_sd # fit MICH and pick L automatically using ELBO fit = mich(Y, L_auto = TRUE) plot(fit, level = 0.95, cs = TRUE, signal = TRUE)"},{"path":"https://davis-berlind.github.io/mich/reference/prob_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Probability vector check. ‚Äî prob_check","title":"Probability vector check. ‚Äî prob_check","text":"prob_check() throws error probs either one string arguments 'uniform' 'weighted', length \\(T\\) vector elements sum one, \\(T \\times n\\) matrix columns sum one.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/prob_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probability vector check. ‚Äî prob_check","text":"","code":"prob_check(probs, n, T)"},{"path":"https://davis-berlind.github.io/mich/reference/prob_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probability vector check. ‚Äî prob_check","text":"probs character, numeric vector, numeric matrix. character, probs equal 'weighted' 'uniform'. vector, elements probs must sum one. matrix, rows probs must sum one. n integer. Number columns probs matrix. T integer. Length number rows probs.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/prob_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probability vector check. ‚Äî prob_check","text":"character, numeric vector, numeric matrix. error thrown evaluation, prob_check() returns probs argument.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/revcumsum.html","id":null,"dir":"Reference","previous_headings":"","what":"Reverse cumulative sum ‚Äî revcumsum","title":"Reverse cumulative sum ‚Äî revcumsum","text":"revcumsum() takes length \\(n\\) vector \\(\\{x_i\\}_{=1}^n\\) returns \\(\\{\\Sigma_{j=}^n x_j\\}_{=1}^n\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/revcumsum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reverse cumulative sum ‚Äî revcumsum","text":"","code":"revcumsum(x)"},{"path":"https://davis-berlind.github.io/mich/reference/revcumsum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reverse cumulative sum ‚Äî revcumsum","text":"x numeric vector.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/revcumsum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reverse cumulative sum ‚Äî revcumsum","text":"numeric vector. Reverse cumulative sum elements x.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/revcumsum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reverse cumulative sum ‚Äî revcumsum","text":"","code":"revcumsum(1:10) #>  [1] 55 54 52 49 45 40 34 27 19 10"},{"path":"https://davis-berlind.github.io/mich/reference/scalar_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Scalar value check. ‚Äî scalar_check","title":"Scalar value check. ‚Äî scalar_check","text":"scalar_check() throws error x equal scalar value.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/scalar_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scalar value check. ‚Äî scalar_check","text":"","code":"scalar_check(x)"},{"path":"https://davis-berlind.github.io/mich/reference/scalar_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scalar value check. ‚Äî scalar_check","text":"x scalar.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/scalar_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scalar value check. ‚Äî scalar_check","text":"scalar error thrown evaluation, scalar_check() returns x argument.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/summary.mich.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for mich.fit objects ‚Äî summary.mich.fit","title":"Summary method for mich.fit objects ‚Äî summary.mich.fit","text":"Prints summary resulting fit calling mich(), including ELBO fitted model, estimated change-points level-level credible sets.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/summary.mich.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for mich.fit objects ‚Äî summary.mich.fit","text":"","code":"# S3 method for class 'mich.fit' summary(object, level = 0.95, max_length = NULL, ...)"},{"path":"https://davis-berlind.github.io/mich/reference/summary.mich.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for mich.fit objects ‚Äî summary.mich.fit","text":"object mich.fit object. Output running mich() numeric vector matrix. level scalar. number (0,1) indicating significance level construct credible sets . max_length integer. Detection threshold, see mich_sets(). Equal \\(\\log^{2}(T)\\) default. ... Additional arguments passed methods.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/summary.mich.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for mich.fit objects ‚Äî summary.mich.fit","text":"list. list summary quantities including: elbo: value ELBO model. converged: Indicator whether model converged. level: significance level used construct credible sets. L,K,J: number mean-scp, var-scp, meanvar-scp components included model. mean_cp,var_cp,meanvar_cp: Lists cp, estimated change-points, sets, corresponding level-level credible sets.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/var_scp.html","id":null,"dir":"Reference","previous_headings":"","what":"Variance Single Change-Point Model ‚Äî var_scp","title":"Variance Single Change-Point Model ‚Äî var_scp","text":"Implementation Var-SCP model Berlind, Cappello, Madrid Padilla (2025). function var_scp() takes length \\(T\\) vector \\(y_{1:T}\\) single variance change returns posterior distribution change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/var_scp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variance Single Change-Point Model ‚Äî var_scp","text":"","code":"var_scp(y, omega, u_bar, lgamma_u_bar, v, log_pi)"},{"path":"https://davis-berlind.github.io/mich/reference/var_scp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variance Single Change-Point Model ‚Äî var_scp","text":"y numeric vector. \\(T\\) observations single variance change. omega numeric vector. Known trend component precision y. u_bar numeric vector. Posterior shape parameters equal \\(u_0 + T - t + 1\\) \\(t\\). lgamma_u_bar numeric vector. Log gamma function evaluated u_bar. v numeric vector. Vector prior rate parameters \\(t\\). log_pi numeric vector. Vector log prior probabilities location change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/var_scp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variance Single Change-Point Model ‚Äî var_scp","text":"list. list posterior parameters including rate v_bar, posterior probabilities change-point location pi_bar.","code":""},{"path":"https://davis-berlind.github.io/mich/news/index.html","id":"mich-001","dir":"Changelog","previous_headings":"","what":"mich 0.0.1","title":"mich 0.0.1","text":"initial release version mich. release introduces: Main package function mich(). Summary plotting S3 methods mich.fit class. NEWS.md file track changes package. Weighted prior functions log_mean_prior(), log_var_prior(), log_meanvar_prior. Datasets well_log.csv, ion_channel.csv, steps.csv Introduction","code":""}]
