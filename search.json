[{"path":"https://davis-berlind.github.io/mich/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 mich authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (â€œSoftwareâ€), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED â€œâ€, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://davis-berlind.github.io/mich/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Davis Berlind. Author, maintainer.","code":""},{"path":"https://davis-berlind.github.io/mich/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Berlind D (2025). mich: Bayesian Change-Point Detection Credible Sets. R package version 0.0.0.9000, https://davis-berlind.github.io/mich/.","code":"@Manual{,   title = {mich: Bayesian Change-Point Detection with Credible Sets},   author = {Davis Berlind},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://davis-berlind.github.io/mich/}, }"},{"path":"https://davis-berlind.github.io/mich/index.html","id":"fast-bayesian-inference-for-change-point-detection","dir":"","previous_headings":"","what":"Bayesian Change-Point Detection with Credible Sets","title":"Bayesian Change-Point Detection with Credible Sets","text":"mich R package implements Multiple Independent Change-Point (MICH) method introduced Berlind, Cappello, Madrid Padilla (2025). main function package mich() takes length TT sequence observations ð²1:T\\mathbf{y}_{1:T} potentially many change-points mean variance, deploys backfitting procedure find variational approximation posterior distribution change-points.","code":""},{"path":"https://davis-berlind.github.io/mich/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bayesian Change-Point Detection with Credible Sets","text":"can install development version mich GitHub using:","code":"# install.packages(\"devtools\") devtools::install_github(\"davis-berlind/mich\")"},{"path":"https://davis-berlind.github.io/mich/reference/cred_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Single Change-Point Posterior Credible Set â€” cred_set","title":"Single Change-Point Posterior Credible Set â€” cred_set","text":"function cred_set() takes length \\(T\\) vector posterior change-point location probabilities \\(\\pi_{1:T}\\) coverage level \\(\\alpha\\), returns smallest set \\(S\\) \\(\\Sigma_{t \\S} \\pi_t \\geq \\alpha\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/cred_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Single Change-Point Posterior Credible Set â€” cred_set","text":"","code":"cred_set(prob, level)"},{"path":"https://davis-berlind.github.io/mich/reference/cred_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Single Change-Point Posterior Credible Set â€” cred_set","text":"prob numeric vector. vector posterior probabilities location change-point. level scalar. single number (0,1) gives lower bound probability credible set contains change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/cred_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Single Change-Point Posterior Credible Set â€” cred_set","text":"vector. Level level posterior credible set location single change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/integer_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Integer value check. â€” integer_check","title":"Integer value check. â€” integer_check","text":"integer_check() throws error n equal positive valued integer.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/integer_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integer value check. â€” integer_check","text":"","code":"integer_check(n)"},{"path":"https://davis-berlind.github.io/mich/reference/integer_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integer value check. â€” integer_check","text":"n integer.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/integer_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integer value check. â€” integer_check","text":"integer. error thrown evaluation, integer_check() returns n argument.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/lambda_bar_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected Precision Signal â€” lambda_bar_fn","title":"Expected Precision Signal â€” lambda_bar_fn","text":"Given \\(V(y_t|s,\\tau)=1/\\lambda_t=1/s^{(t\\geq \\tau)}\\), \\(P(\\tau=t)=\\pi_t\\), \\(\\bar{u}_t/\\bar{v}_t=E[s|\\tau=t]\\), lambda_bar_fn() calculates \\(E[\\lambda_t]\\) \\(1 - \\Sigma_{t'=1}^t \\pi_{t'}(1 - \\bar{v}_{t'} / \\bar{u}_{t'})\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/lambda_bar_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected Precision Signal â€” lambda_bar_fn","text":"","code":"lambda_bar_fn(u, v, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/lambda_bar_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected Precision Signal â€” lambda_bar_fn","text":"u numeric vector. Length \\(T\\) vector conditional shape parameters v numeric vector. Length \\(T\\) vector conditional rate parameters prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/lambda_bar_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected Precision Signal â€” lambda_bar_fn","text":"numeric vector. length \\(T\\) vector \\(E[\\lambda_t]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_mean_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Weighted Mean-SCP Prior â€” log_mean_prior","title":"Log Weighted Mean-SCP Prior â€” log_mean_prior","text":"Log weighted prior Mean-SCP model described Appendix C.2 Berlind, Cappello, Madrid Padilla (2025). prior ensures absence change-point, posterior probabilities approximately uniform.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_mean_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Weighted Mean-SCP Prior â€” log_mean_prior","text":"","code":"log_mean_prior(T, d)"},{"path":"https://davis-berlind.github.io/mich/reference/log_mean_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Weighted Mean-SCP Prior â€” log_mean_prior","text":"T integer. Number observations (rows) \\(\\mathbf{y}_{1:T}\\). d integer. Dimension (columns) \\(\\mathbf{y}_{1:T}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_mean_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Weighted Mean-SCP Prior â€” log_mean_prior","text":"numeric vector. Log prior probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_meanvar_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Weighted MeanVar-SCP Prior â€” log_meanvar_prior","title":"Log Weighted MeanVar-SCP Prior â€” log_meanvar_prior","text":"Log weighted prior MeanVar-SCP model described Appendix C.2 Berlind, Cappello, Madrid Padilla (2025). prior ensures absence change-point, posterior probabilities approximately uniform.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_meanvar_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Weighted MeanVar-SCP Prior â€” log_meanvar_prior","text":"","code":"log_meanvar_prior(T)"},{"path":"https://davis-berlind.github.io/mich/reference/log_meanvar_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Weighted MeanVar-SCP Prior â€” log_meanvar_prior","text":"T integer. Number observations \\(y_{1:T}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_meanvar_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Weighted MeanVar-SCP Prior â€” log_meanvar_prior","text":"numeric vector. Log prior probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_var_prior.html","id":null,"dir":"Reference","previous_headings":"","what":"Log Weighted Var-SCP Prior â€” log_var_prior","title":"Log Weighted Var-SCP Prior â€” log_var_prior","text":"Log weighted prior Var-SCP model described Appendix C.2 Berlind, Cappello, Madrid Padilla (2025). prior ensures absence change-point, posterior probabilities approximately uniform.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_var_prior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log Weighted Var-SCP Prior â€” log_var_prior","text":"","code":"log_var_prior(T)"},{"path":"https://davis-berlind.github.io/mich/reference/log_var_prior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log Weighted Var-SCP Prior â€” log_var_prior","text":"T integer. Number observations \\(y_{1:T}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/log_var_prior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log Weighted Var-SCP Prior â€” log_var_prior","text":"numeric vector. Log prior probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/logical_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical value check. â€” logical_check","title":"Logical value check. â€” logical_check","text":"logical_check() throws error x equal either TRUE FALSE.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/logical_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical value check. â€” logical_check","text":"","code":"logical_check(x)"},{"path":"https://davis-berlind.github.io/mich/reference/logical_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical value check. â€” logical_check","text":"x logical.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/logical_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical value check. â€” logical_check","text":"logical. error thrown evaluation, logical_check() returns x argument.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mean_scp.html","id":null,"dir":"Reference","previous_headings":"","what":"Mean Single Change-Point Model â€” mean_scp","title":"Mean Single Change-Point Model â€” mean_scp","text":"Implementation univariate Mean-SCP model Berlind, Cappello, Madrid Padilla (2025). function mean_scp() takes length \\(T\\) vector \\(y_{1:T}\\) single mean change returns posterior distribution change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mean_scp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mean Single Change-Point Model â€” mean_scp","text":"","code":"mean_scp(y, lambda, omega, log_pi)"},{"path":"https://davis-berlind.github.io/mich/reference/mean_scp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mean Single Change-Point Model â€” mean_scp","text":"y numeric vector. \\(T\\) observations single variance change. lambda numeric vector. Precision vector y. omega positive scalar. Prior precision parameter. log_pi numeric vector. Vector log prior probabilities location change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mean_scp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mean Single Change-Point Model â€” mean_scp","text":"list. list posterior parameters including mean b_bar, precision omega_bar, posterior probabilities change-point location pi_bar.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/meanvar_scp.html","id":null,"dir":"Reference","previous_headings":"","what":"Mean-Variance Single Change-Point Model â€” meanvar_scp","title":"Mean-Variance Single Change-Point Model â€” meanvar_scp","text":"Implementation MeanVar-SCP model Berlind, Cappello, Madrid Padilla (2025). function meanvar_scp() takes length \\(T\\) vector \\(y_{1:T}\\) single joint mean variance change returns posterior distribution change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/meanvar_scp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mean-Variance Single Change-Point Model â€” meanvar_scp","text":"","code":"meanvar_scp(y, lambda, omega, u_bar, lgamma_u_bar, v, log_pi)"},{"path":"https://davis-berlind.github.io/mich/reference/meanvar_scp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mean-Variance Single Change-Point Model â€” meanvar_scp","text":"y numeric vector. \\(T\\) observations single joint mean variance change. lambda numeric vector. Known trend component precision y. omega positive scalar. Prior precision parameter. u_bar numeric vector. Posterior shape parameters equal \\(u_0 + T - t + 1\\) \\(t\\). lgamma_u_bar numeric vector. Log gamma function evaluated u_bar. v numeric vector. Vector prior rate parameters \\(t\\). log_pi numeric vector. Vector log prior probabilities location change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/meanvar_scp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mean-Variance Single Change-Point Model â€” meanvar_scp","text":"list. list posterior parameters including  mean b_bar, precision omega_bar, rate v_bar, posterior probabilities change-point location pi_bar.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiple Independent Change-Point (MICH) Model â€” mich","title":"Multiple Independent Change-Point (MICH) Model â€” mich","text":"Implementation MICH model described Berlind, Cappello, Madrid Padilla. MICH Bayesian change-point detection method can quantify uncertainty around estimated change-points form credible sets.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiple Independent Change-Point (MICH) Model â€” mich","text":"","code":"mich(   y,   fit_intercept = TRUE,   fit_scale = TRUE,   standardize = TRUE,   J = 0,   L = 0,   K = 0,   J_auto = FALSE,   L_auto = FALSE,   K_auto = FALSE,   J_max = Inf,   L_max = Inf,   K_max = Inf,   tol = 1e-05,   merge_prob = NULL,   merge_level = 0.95,   max_iter = 10000,   verbose = FALSE,   reverse = FALSE,   restart = TRUE,   increment = 1,   omega_j = 0.001,   u_j = 0.001,   v_j = 0.001,   pi_j = \"weighted\",   omega_l = 0.001,   pi_l = \"weighted\",   u_k = 0.001,   v_k = 0.001,   pi_k = \"weighted\" )"},{"path":"https://davis-berlind.github.io/mich/reference/mich.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiple Independent Change-Point (MICH) Model â€” mich","text":"y numeric vector matrix. length \\(T\\) vector observations exhibiting change-points mean /variance series, \\(T \\times d\\) matrix observations exhibiting just mean changes. fit_intercept logical. fit_intercept == TRUE, intercept estimated, otherwise assumed  \\(\\mu_0 = 0\\). fit_scale logical. fit_scale == TRUE, initial precision estimated, otherwise assumed  \\(\\lambda_0 = 1\\) (\\(\\Lambda_0 = \\mathbf{}_d\\) y matrix). standardize logical. standardize == TRUE, y centered rescaled fitting. L, J, K Integers. Respective number mean-scp, var-scp, meanvar-scp components included model. L_auto == TRUE, K_auto == TRUE, J_auto == TRUE L, K, J lower bound number kind change-point model. L_auto, K_auto, J_auto Logicals. L_auto == TRUE, K_auto == TRUE, /J_auto == TRUE, mich_vector() searches forr returns \\(L\\) L L_max, \\(K\\) K K_max, /\\(J\\) J J_max maximize ELBO (see Appendix C.4 Berlind, Cappello, Madrid Padilla (2025)). L_max, K_max, J_max Integers. L_auto == TRUE, K_auto == TRUE, J_auto == TRUE L_max, K_max, J_max upper bound number kind change-point model. tol scalar. Convergence tolerance relative increase ELBO. \\((\\text{ELBO}_{t+1}-\\text{ELBO}_t)/ \\text{ELBO}_t\\) falls tol variational algorithm terminates. merge_prob scalar. value (0,1) indicating merge criterion. posterior probability two components identify change greater merge_level, components merged (see Appendix C.3 Berlind, Cappello, Madrid Padilla (2025)). merge_level scalar. value (0,1) significance level construct credible sets merging. model component considered candidate merging merge_level-level credible set contains fewer detect indices. max_iter integer. Maximum number variational iterations. ELBO converge max_iter reached, converged == FALSE returned fit object. verbose logical. verbose == TRUE L_auto == FALSE, K_auto == FALSE, J_auto == FALSE value ELBO printed every 5000th iteration. verbose == TRUE L_auto, K_auto, J_auto TRUE, value ELBO printed combinatin \\((L,K,J)\\) mich_vector() searches parameterization maximized EBLO. reverse logical. reverse == TRUE MICH fit \\(\\mathbf{y}_{T:1}\\) model parameters reversed post-processing. restart logical. restart == TRUE L_auto, K_auto, J_auto TRUE, n_search increments L, K, /J, ELBO increased, mich_vector() restart setting L, K, J components null model initialization (except components maximum posterior probabilities > 0.9) refit begin search . increment integer. Number components increment L, K J L_auto, K_auto, J_auto TRUE. omega_j, u_j, v_j Scalars. Prior precision, shape, rate parameters meanvar-scp components model. pi_j character numeric vector matrix. Prior meanvar-scp model components. Must either length \\(T\\) vector entries sum one, \\(T \\times J\\) matrix columns sum one, character equal \"weighted\" \"uniform\". pi_j vector J > 1, pi_j used prior J meanvar-scp components model. pi_j == \"uniform\" uniform prior \\(\\pi_{jt} = 1/T\\) used components. pi_j == \"weighted\" log_meanvar_prior() used calculate weighted prior described Appendix C.2 Berlind, Cappello, Madrid Padilla (2025). J_auto == TRUE must case pi_j %% c(\"uniform\", \"weighted\"). omega_l scalar. Prior precision parameter mean-scp components model. y matrix prior precision \\(\\omega_\\ell\\mathbf{}_d\\). pi_l character numeric vector matrix. Prior mean-scp model components. Must either length \\(T\\) vector entries sum one, \\(T \\times L\\) matrix columns sum one, character equal \"weighted\" \"uniform\". pi_l vector L > 1, pi_l used prior L mean-scp components. pi_l == \"uniform\" uniform prior \\(\\pi_{\\ell t} = 1/T\\) used components. pi_l == \"weighted\" log_mean_prior() used calculate weighted prior described Appendix C.2 Berlind, Cappello, Madrid Padilla (2025). L_auto == TRUE must case pi_l %% c(\"uniform\", \"weighted\"). u_k, v_k Scalar. Prior shape rate parameters var-scp components model. pi_k character numeric vector matrix. Prior var-scp model components. Must either length \\(T\\) vector entries sum one, \\(T \\times K\\) matrix columns sum one, character equal \"weighted\" \"uniform\". pi_k vector K > 1, pi_k used prior K var-scp components. pi_k == \"uniform\" uniform prior \\(\\pi_{k t} = 1/T\\) used components. pi_k == \"weighted\" log_var_prior() used calculate weighted prior described Appendix C.2 Berlind, Cappello, Madrid Padilla (2025). K_auto == TRUE must case pi_k %% c(\"uniform\", \"weighted\").","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiple Independent Change-Point (MICH) Model â€” mich","text":"list. Parameters variational approximation MICH posterior distribution. y vector, list includes: y: numeric vector. Original data. L,K,J: Integers. Number mean-scp, var-scp, meanvar-scp components included model. residual: numeric vector. Residual \\(\\tilde{\\mathbf{r}}_{1:T}\\) (see (B.4) Berlind, Cappello, Madrid Padilla (2025)). mu: numeric vector. Posterior estimate \\(\\Sigma_{\\ell=1}^L E[\\boldsymbol{\\mu}_{\\ell,1:T}|\\mathbf{y}_{1:T}] + \\Sigma_{j=1}^J E[\\boldsymbol{\\mu}_{j,1:T}|\\mathbf{y}_{1:T}]\\). lambda: numeric vector. Posterior estimate \\(\\Pi_{k=1}^K E[\\boldsymbol{\\lambda}_{k,1:T}|\\mathbf{y}_{1:T}] \\times \\Pi_{j=1}^J E[\\boldsymbol{\\lambda}_{j,1:T}|\\mathbf{y}_{1:T}]\\). delta: numeric vector. Posterior estimate equation (B.4) Berlind, Cappello, Madrid Padilla (2025). mu_0: scalar. Estimate intercept. lambda_0: scalar. Estimate initial precision. elbo: numeric vector. Value ELBO iteration. converged: logical. Indicates whether relative increase ELBO less tol. meanvar_model: list. List meanvar-scp posterior parameters: pi_bar: numeric matrix. \\(T \\times J\\) matrix posterior change-point location probabilities. b_bar: numeric matrix. \\(T \\times J\\) matrix posterior mean parameters. omega_bar: numeric matrix. \\(T \\times J\\) matrix posterior precision parameters. v_bar: numeric matrix. \\(T \\times J\\) matrix posterior rate parameters. u_bar: numeric vector. length \\(T\\) vector posterior shape parameters. mu_lambda_bar: numeric matrix. \\(T \\times J\\) matrix scaled posterior mean signals \\(E[\\lambda_{jt}\\mu_{jt}|\\mathbf{y}_{1:T}]\\). mu2_lambda_bar: numeric matrix. \\(T \\times J\\) matrix scaled posterior squared mean signals \\(E[\\lambda_{jt}\\mu^2_{jt}|\\mathbf{y}_{1:T}]\\). lambda_bar: numeric matrix. \\(T \\times J\\) matrix posterior precision signals \\(E[\\lambda_{jt}|\\mathbf{y}_{1:T}]\\). mean_model: list. List mean-scp posterior parameters: pi_bar: numeric matrix. \\(T \\times L\\) matrix posterior change-point location probabilities. b_bar: numeric matrix. \\(T \\times L\\) matrix posterior mean parameters. omega_bar: numeric matrix. \\(T \\times L\\) matrix posterior precision parameters. mu_bar: numeric matrix. \\(T \\times L\\) matrix posterior mean signals \\(E[\\mu_{\\ell t}|\\mathbf{y}_{1:T}]\\). mu2_bar: numeric matrix. \\(T \\times L\\) matrix posterior squared mean signals \\(E[\\mu_{\\ell t}^2|\\mathbf{y}_{1:T}]\\). var_model: list. List var-scp posterior parameters: pi_bar: numeric matrix. \\(T \\times K\\) matrix posterior change-point location probabilities. v_bar: numeric matrix. \\(T \\times K\\) matrix posterior rate parameters. u_bar: numeric vector. length \\(T\\) vector posterior shape parameters. lambda_bar: numeric matrix. \\(T \\times K\\) matrix posterior precision signals \\(E[\\lambda_{kt}|\\mathbf{y}_{1:T}]\\). y vector, list includes: y: numeric matrix. Original data. Sigma: numeric matrix. Estimate \\(\\Lambda^{-1}\\) fit_scale == TRUE. L: integer. Number components included model. pi_bar: numeric matrix.  \\(T \\times L\\) matrix posterior change-point location probabilites. residual: numeric matrix. Residual \\(\\mathbf{r}_{1:T}\\) subtracting \\(E[\\boldsymbol{\\mu}_{\\ell t}]\\) \\(\\mathbf{y}_{1:T}\\). mu: numeric matrix. Posterior estimate \\(\\Sigma_{\\ell=1}^L E[\\boldsymbol{\\mu}_{\\ell,1:T}|\\mathbf{y}_{1:T}]\\). mu_0: numeric vector. Estimate intercept. post_params: list. List posterior parameters mean-scp component. elbo: numeric vector. Value ELBO iteration. converged: logical. Indicates whether relative increase ELBO less tol.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiple Independent Change-Point (MICH) Model â€” mich","text":"","code":"set.seed(222) # generate univariate data with two mean-variance change-points y = c(rnorm(100,0,10), rnorm(100,10,3), rnorm(100,0,6)) fit = mich(y, J = 2) # fit two mean-variance change-points # plot change-points with 95% credible sets plot(fit, level = 0.95, cs = TRUE)  # fit one mean and one mean-variance change-point fit = mich(y, J = 1, L = 1) # plot change-points with 95% credible sets and signal plot(fit, level = 0.95, cs = TRUE, signal = TRUE)   # generate correlated mulitvariate data with two mean-variance change-points T <- 150 Sigma <- rbind(c(1, 0.7), c(0.7, 2)) d <- ncol(Sigma) Sigma_eigen <- eigen(Sigma) e_vectors <- Sigma_eigen$vectors e_values <- Sigma_eigen$values Sigma_sd <- e_vectors %*% diag(sqrt(e_values)) %*% t(e_vectors) Z <- sapply(1:d, function(i) rnorm(T)) mu <- c(-1, 2) mu_t <- matrix(0, nrow = 70, ncol=d) mu_t <- rbind(mu_t, t(sapply(1:30, function(i) mu))) mu_t <- rbind(mu_t, matrix(0, nrow = 50, ncol = d)) Y <- mu_t + Z %*% Sigma_sd # fit MICH and pick L automatically using ELBO fit = mich(Y, L_auto = TRUE) plot(fit, level = 0.95, cs = TRUE, signal = TRUE)"},{"path":"https://davis-berlind.github.io/mich/reference/mich_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"MICH Algorithm â€” mich_cpp","title":"MICH Algorithm â€” mich_cpp","text":"Implementation Algorithms 1 & 2 Berlind, Cappello, Madrid Padilla (2025). algorithm takes sequence \\(T\\) observations \\(\\mathbf{y}_{1:T}\\), iteratively fits \\(L\\) mean-scp models, \\(K\\) var-scp models, \\(J\\) meanvar-scp models resulting variational approximation posterior distribution \\(L\\) mean, \\(K\\) variance, \\(J\\) mean variance change-points. algorithm terminates percentage increase ELBO falls tol.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MICH Algorithm â€” mich_cpp","text":"","code":"mich_cpp(   y,   J,   L,   K,   mu_0,   lambda_0,   fit_intercept,   fit_scale,   refit,   max_iter,   verbose,   tol,   omega_j,   u_j,   v_j,   log_pi_j,   pi_bar_j,   log_pi_bar_j,   b_bar_j,   omega_bar_j,   u_bar_j,   v_bar_j,   lgamma_u_bar_j,   digamma_u_bar_j,   omega_l,   log_pi_l,   pi_bar_l,   log_pi_bar_l,   b_bar_l,   omega_bar_l,   u_k,   v_k,   log_pi_k,   pi_bar_k,   log_pi_bar_k,   u_bar_k,   v_bar_k,   lgamma_u_bar_k,   digamma_u_bar_k )"},{"path":"https://davis-berlind.github.io/mich/reference/mich_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MICH Algorithm â€” mich_cpp","text":"y numeric vector. Length \\(T\\) vector observations. L, K, J Integers. number mean, variance, mean-variance change-points include model. mu_0 scalar. Intercept parameter initialization. lambda_0 scalar. Baseline scale parameter initialization. fit_intercept logical. fit_intercept == TRUE, intercept estimated mu_0 gets updated. fit_scale logical. fit_scale == TRUE, initial scale estimated lambda_0 gets updated. refit logical. refit == TRUE, MICH algorithm initialized using provided posterior parameters, otherwise null model \\(\\mu_t = 0\\), \\(\\lambda_t = 1\\) \\(\\bar{\\pi}_{\\ell t} = \\bar{\\pi}_{k t} = \\bar{\\pi}_{j t}  = 1/T\\) used initialization. max_iter integer. Maximum number iterations. ELBO converge max_iter reached, converged == FALSE returned fit object. verbose logical. verbose == TRUE, value ELBO printed every 5000th iteration. tol scalar. Convergence tolerance relative increase ELBO. omega_j, u_j, v_j Scalars. Prior precision, shape, rate parameters meanvar-scp components model. log_pi_j numeric matrix. \\(T \\times J\\) matrix prior log change-point location probabilities \\(J\\) mean-variance change-points. pi_bar_j, log_pi_bar_j Numeric matrices. \\(T \\times J\\) matrices initialized posterior change-point location probabilities log evaluations \\(J\\) mean-variance change-points. b_bar_j numeric matrix. \\(T \\times J\\) matrix initialized posterior mean parameters \\(J\\) mean-variance change-points. omega_bar_j numeric matrix. \\(T\\times J\\) matrix initialized posterior precision parameters \\(J\\) mean-variance change-points. u_bar_j, lgamma_u_bar_j, digamma_u_bar_j Numeric vectors. Length \\(T\\) vectors posterior shape parameters meanvar-scp model components log-gamma digamma evaluations. v_bar_j numeric matrix. \\(T \\times J\\) matrix initialized posterior rate parameters \\(J\\) mean-variance change-points. omega_l scalar. Prior precision parameter mean-scp components model. log_pi_l numeric matrix. \\(T \\times L\\) matrix prior log change-point location probabilities \\(L\\) mean change-points. pi_bar_l, log_pi_bar_l Numeric matrices. \\(T \\times L\\) matrices initialized posterior change-point location probabilities log evaluations \\(L\\) mean change-points. b_bar_l numeric matrix. \\(T \\times L\\) matrix initialized posterior mean parameters \\(L\\) mean change-points. omega_bar_l numeric matrix. \\(T\\times L\\) matrix initialized posterior precision parameters \\(L\\) mean change-points. u_k, v_k Scalars. Prior shape rate parameters var-scp components model. log_pi_k numeric matrix. \\(T \\times K\\) matrix prior log change-point location probabilities \\(K\\) variance change-points. pi_bar_k, log_pi_bar_k Numeric matrices. \\(T \\times K\\) matrices initialized posterior change-point location probabilities log evaluations \\(K\\) variance change-points. u_bar_k, lgamma_u_bar_k, digamma_u_bar_k Numeric vectors. Length \\(T\\) vectors posterior shape parameters var-scp model components log-gamma digamma evaluations. v_bar_k numeric matrix. \\(T \\times K\\) matrix initialized posterior rate parameters \\(K\\) variance change-points.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MICH Algorithm â€” mich_cpp","text":"List. Parameters variational approximation MICH posterior distribution, including: y: numeric vector. Original data set. residual: numeric vector. Residual \\(\\mathbf{r}_{1:T}\\) subtracting \\(E[\\mu_{\\ell t}]\\) \\(E[\\lambda_{j t} \\mu_{j t}]/E[\\lambda_{j t}]\\) \\(\\mathbf{y}_{1:T}\\). mu: numeric vector. Posterior estimate \\(\\Sigma_{\\ell=1}^L E[\\mu_{\\ell,1:T}|\\mathbf{y}_{1:T}] + \\Sigma_{j=1}^J E[\\mu_{j,1:T}|\\mathbf{y}_{1:T}]\\). lambda: numeric vector. Posterior estimate \\(\\Pi_{\\\\k=1}^K E[\\lambda_{k,1:T}|\\mathbf{y}_{1:T}] \\times \\Pi_{j=1}^J E[\\lambda_{j,1:T}|\\mathbf{y}_{1:T}]\\). delta: numeric vector. Posterior variance correction term (see (B.6) Berlind, Cappello, Madrid Padilla (2025)). converged: logical. Indicates whether relative increase ELBO less tol. elbo: numeric vector. Value ELBO iteration. mu_0: scalar. Estimate intercept. lambda_0: scalar. Estimate initial precision. J, L, K: Integers. number mean, variance, mean-variance components. J_model: list. list posterior parameters \\(J\\) meanvar-scp components (included J > 0). L_model: list. list posterior parameters \\(L\\) mean-scp components (included L > 0). K_model: list. list posterior parameters \\(K\\) var-scp components (included K > 0).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate Multiple Independent Change-Point (MICH) Model â€” mich_matrix","title":"Multivariate Multiple Independent Change-Point (MICH) Model â€” mich_matrix","text":"Fits multivariate version MICH model mean change-points. Number change-points can either fixed mich_matrix() search number changes maximizes ELBO L_auto == TRUE.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate Multiple Independent Change-Point (MICH) Model â€” mich_matrix","text":"","code":"mich_matrix(   y,   fit_intercept,   fit_scale,   standardize,   L,   L_auto,   L_max,   pi_l_weighted,   tol,   verbose,   max_iter,   reverse,   detect,   merge_level,   merge_prob,   restart,   n_search,   increment,   omega_l,   log_pi_l )"},{"path":"https://davis-berlind.github.io/mich/reference/mich_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate Multiple Independent Change-Point (MICH) Model â€” mich_matrix","text":"y numeric matrix. \\(T \\times d\\) matrix observations. fit_intercept logical. fit_intercept == TRUE, intercept estimated, otherwise assumed  \\(\\boldsymbol{\\mu}_0 = \\mathbf{0}\\). fit_scale logical. fit_scale == TRUE, precision matrix \\(\\Lambda = E[\\mathbf{y}_t\\mathbf{y}'_t]^{-1}\\) estimated using \\(\\hat{\\Lambda}^{-1} = \\frac{1}{2(T-1)} \\Sigma_{t=1}^{T-1} (\\mathbf{y}_{t+1} - \\mathbf{y}_{t})(\\mathbf{y}_{t+1} - \\mathbf{y}_{t})'\\), otherwise assumed \\(\\Lambda = \\mathbf{}_d\\). standardize logical. standardize == TRUE, y centered rescaled fitting. L integer. Number mean-scp components included model. L_auto == TRUE L lower bounds number change-points model. L_auto logical. L_auto == TRUE, mich_matrix() returns \\(L\\) L L_max maximizes ELBO (see Appendix C.4 Berlind, Cappello, Madrid Padilla (2025)). L_max L integer. L_auto == TRUE L_max upper bounds number change-points included model. pi_l_weighted logical. pi_l_weighted == TRUE, weighted priors specified Appendix C.2 Berlind, Cappello, Madrid Padilla (2025) used. tol scalar. Convergence tolerance relative increase ELBO. verbose logical. verbose == TRUE L_auto == FALSE, value ELBO printed every 5000th iteration. verbose == TRUE L_auto == TRUE, value ELBO printed \\(L\\) mich_matrix() searches [L, L_max]. max_iter integer. Maximum number iterations. ELBO converge max_iter reached, converged == FALSE returned fit object. reverse logical. reverse == TRUE MICH fit \\(\\mathbf{y}_{T:1}\\) model parameters reversed post-processing. detect scalar. detection criteria. \\(\\ell^{\\text{th}}\\) component model detects change-point posterior credible set component contains fewer detect indices. merge_level scalar. value (0,1) significance level construct credible sets merging. model component considered candidate merging merge_level-level credible set contains fewer detect indices. merge_prob scalar. value (0,1) indicating merge criterion. posterior probability two components identify change greater merge_level, components merged (see Appendix C.3 Berlind, Cappello, Madrid Padilla (2025)). restart logical. restart == TRUE L_auto == TRUE n_search increments L, ELBO increased, mich_matrix() restart setting L components null model initialization (except components maximum posterior probabilities > 0.9) refit begin search . n_search integer. Grid search parameter. Number times increment L terminating automatic procedure L_auto == TRUE. increment integer. Number components increment L L_auto == TRUE. omega_l scalar. Prior precision parameter mean-scp components model. log_pi_l numeric matrix. \\(T \\times L\\) matrix prior log change-point location probabilities \\(L\\) mean change-points.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate Multiple Independent Change-Point (MICH) Model â€” mich_matrix","text":"list. Parameters variational approximation MICH posterior distribution, including: y: numeric matrix. Original data. Sigma: numeric matrix. Estimate \\(\\Lambda^{-1}\\) fit_scale == TRUE. L: integer. Number components included model. pi_bar: numeric matrix.  \\(T \\times L\\) matrix posterior change-point location probabilites. residual: numeric matrix. Residual \\(\\mathbf{r}_{1:T}\\) subtracting \\(E[\\boldsymbol{\\mu}_{\\ell t}]\\) \\(\\mathbf{y}_{1:T}\\). mu: numeric matrix. Posterior estimate \\(\\Sigma_{\\ell=1}^L E[\\boldsymbol{\\mu}_{\\ell,1:T}|\\mathbf{y}_{1:T}]\\). mu_0: numeric vector. Estimate intercept. post_params: list. List posterior parameters mean-scp component. elbo: numeric vector. Value ELBO iteration. converged: logical. Indicates whether relative increase ELBO less tol.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_sets.html","id":null,"dir":"Reference","previous_headings":"","what":"MICH Posterior Credible Sets â€” mich_sets","title":"MICH Posterior Credible Sets â€” mich_sets","text":"function mich_sets() takes \\(T \\times N\\) matrix posterior change-point location probabilities \\(\\{\\pi_{,1:T}\\}_{=1}^N\\), coverage level \\(\\alpha\\), max set length, \\(1\\leq \\leq N\\) returns MAP estimator \\(\\arg\\max_{1\\leq t \\leq T} \\pi_{}\\) smallest set \\(S_i\\) \\(\\Sigma_{t \\S_i} \\pi_{} \\geq \\alpha\\) \\(|S_i|<\\) max_length.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_sets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"MICH Posterior Credible Sets â€” mich_sets","text":"","code":"mich_sets(probs, max_length = log(nrow(probs))^1.5, level = 0.9)"},{"path":"https://davis-berlind.github.io/mich/reference/mich_sets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"MICH Posterior Credible Sets â€” mich_sets","text":"probs numeric Matrix. \\(T \\times N\\) matrix posterior probabilities location change-points. max_length positive scalar. Detection threshold, credible set contains max_length indices, change detected. Set equal \\(\\log^{1.5} T\\) default (see Section 2.5 Berlind, Cappello, Madrid Padilla (2025)). level scalar. single number (0,1) gives lower bound probability credible set contains change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_sets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"MICH Posterior Credible Sets â€” mich_sets","text":"list. MAP estimator change-point corresponding credible set.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate Multiple Independent Change-Point (MICH) Model â€” mich_vector","title":"Univariate Multiple Independent Change-Point (MICH) Model â€” mich_vector","text":"Fits univariate version MICH model mean variance change-points. Number change-points can either fixed mich_vector() search number changes maximizes ELBO (L_auto | K_auto | J_auto) == TRUE.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate Multiple Independent Change-Point (MICH) Model â€” mich_vector","text":"","code":"mich_vector(   y,   fit_intercept,   fit_scale,   standardize,   J,   L,   K,   J_auto,   L_auto,   K_auto,   J_max,   L_max,   K_max,   pi_j_weighted,   pi_l_weighted,   pi_k_weighted,   tol,   verbose,   max_iter,   reverse,   detect,   merge_level,   merge_prob,   restart,   n_search,   increment,   omega_j,   u_j,   v_j,   log_pi_j,   omega_l,   log_pi_l,   u_k,   v_k,   log_pi_k )"},{"path":"https://davis-berlind.github.io/mich/reference/mich_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate Multiple Independent Change-Point (MICH) Model â€” mich_vector","text":"y numeric vector. Length \\(T\\) vector observations. fit_intercept logical. fit_intercept == TRUE, intercept estimated, otherwise assumed  \\(\\mu_0 = 0\\). fit_scale logical. fit_scale == TRUE, initial precision estimated, otherwise assumed  \\(\\lambda_0 = 1\\). standardize logical. standardize == TRUE, y centered rescaled fitting. L, K, J Integers. Respective number mean-scp, var-scp, meanvar-scp components included model. L_auto == TRUE, K_auto == TRUE, J_auto == TRUE L, K, J lower bound number kind change-point model. L_auto, K_auto, J_auto Logicals. L_auto == TRUE, K_auto == TRUE, /J_auto == TRUE, mich_vector() returns \\(L\\) L L_max, \\(K\\) K K_max, /\\(J\\) J J_max maximize ELBO (see Appendix C.4 Berlind, Cappello, Madrid Padilla (2025)). L_max, K_max, J_max Integers. L_auto == TRUE, K_auto == TRUE, J_auto == TRUE L_max, K_max, J_max upper bound number kind change-point model. pi_l_weighted, pi_k_weighted, pi_j_weighted Logicals. TRUE, weighted priors specified Appendix C.2 Berlind, Cappello, Madrid Padilla (2025) used. tol scalar. Convergence tolerance relative increase ELBO. verbose logical. verbose == TRUE L_auto == FALSE, K_auto == FALSE, J_auto == FALSE value ELBO printed every 5000th iteration. verbose == TRUE L_auto, K_auto, J_auto TRUE, value ELBO printed combinatin \\((L,K,J)\\) mich_vector() searches parameterization maximized EBLO. max_iter integer. Maximum number iterations. ELBO converge max_iter reached, converged == FALSE returned fit object. reverse logical. reverse == TRUE MICH fit \\(\\mathbf{y}_{T:1}\\) model parameters reversed post-processing. detect scalar. detection criteria. \\(^{\\text{th}}\\) component model detects change-point posterior credible set component contains fewer detect indices. merge_level scalar. value (0,1) significance level construct credible sets merging. model component considered candidate merging merge_level-level credible set contains fewer detect indices. merge_prob scalar. value (0,1) indicating merge criterion. posterior probability two components identify change greater merge_level, components merged (see Appendix C.3 Berlind, Cappello, Madrid Padilla (2025)). restart logical. restart == TRUE L_auto, K_auto, J_auto TRUE, n_search increments L, K, /J, ELBO increased, mich_vector() restart setting L, K, J components null model initialization (except components maximum posterior probabilities > 0.9) refit begin search . n_search integer. Grid search parameter. Number times increment L, K, /J terminating automatic procedure L_auto, K_auto, J_auto TRUE. increment integer. Number components increment L, K J L_auto, K_auto, J_auto TRUE. omega_j scalar. Prior precision parameter meanvar-scp components model. u_j scalar. Prior shape parameter meanvar-scp components model. v_j scalar. Prior rate parameter meanvar-scp components model. log_pi_j numeric matrix. \\(T \\times J\\) matrix prior log change-point location probabilities \\(J\\) mean-variance change-points. omega_l scalar. Prior precision parameter mean-scp components model. log_pi_l numeric matrix. \\(T \\times L\\) matrix prior log change-point location probabilities \\(L\\) mean change-points. u_k scalar. Prior shape parameter var-scp components model. v_k scalar. Prior rate parameter var-scp components model. log_pi_k numeric matrix. \\(T \\times K\\) matrix prior log change-point location probabilities \\(K\\) variance change-points.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mich_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate Multiple Independent Change-Point (MICH) Model â€” mich_vector","text":"list. Parameters variational approximation MICH posterior distribution, including: y: numeric vector. Original data. L,K,J: Integers. Number mean-scp, var-scp, meanvar-scp components included model. residual: numeric vector. Residual \\(\\tilde{\\mathbf{r}}_{1:T}\\) (see (B.4) Berlind, Cappello, Madrid Padilla (2025)). mu: numeric vector. Posterior estimate \\(\\Sigma_{\\ell=1}^L E[\\boldsymbol{\\mu}_{\\ell,1:T}|\\mathbf{y}_{1:T}] + \\Sigma_{j=1}^J E[\\boldsymbol{\\mu}_{j,1:T}|\\mathbf{y}_{1:T}]\\). lambda: numeric vector. Posterior estimate \\(\\Pi_{k=1}^K E[\\boldsymbol{\\lambda}_{k,1:T}|\\mathbf{y}_{1:T}] \\times \\Pi_{j=1}^J E[\\boldsymbol{\\lambda}_{j,1:T}|\\mathbf{y}_{1:T}]\\). delta: numeric vector. Posterior estimate equation (B.4) Berlind, Cappello, Madrid Padilla (2025). mu_0: scalar. Estimate intercept. lambda_0: scalar. Estimate initial precision. elbo: numeric vector. Value ELBO iteration. converged: logical. Indicates whether relative increase ELBO less tol. meanvar_model: list. List meanvar-scp posterior parameters: pi_bar: numeric matrix. \\(T \\times J\\) matrix posterior change-point location probabilities. b_bar: numeric matrix. \\(T \\times J\\) matrix posterior mean parameters. omega_bar: numeric matrix. \\(T \\times J\\) matrix posterior precision parameters. v_bar: numeric matrix. \\(T \\times J\\) matrix posterior rate parameters. u_bar: numeric vector. length \\(T\\) vector posterior shape parameters. mu_lambda_bar: numeric matrix. \\(T \\times J\\) matrix scaled posterior mean signals \\(E[\\lambda_{jt}\\mu_{jt}|\\mathbf{y}_{1:T}]\\). mu2_lambda_bar: numeric matrix. \\(T \\times J\\) matrix scaled posterior squared mean signals \\(E[\\lambda_{jt}\\mu^2_{jt}|\\mathbf{y}_{1:T}]\\). lambda_bar: numeric matrix. \\(T \\times J\\) matrix posterior precision signals \\(E[\\lambda_{jt}|\\mathbf{y}_{1:T}]\\). mean_model: list. List mean-scp posterior parameters: pi_bar: numeric matrix. \\(T \\times L\\) matrix posterior change-point location probabilities. b_bar: numeric matrix. \\(T \\times L\\) matrix posterior mean parameters. omega_bar: numeric matrix. \\(T \\times L\\) matrix posterior precision parameters. mu_bar: numeric matrix. \\(T \\times L\\) matrix posterior mean signals \\(E[\\mu_{\\ell t}|\\mathbf{y}_{1:T}]\\). mu2_bar: numeric matrix. \\(T \\times L\\) matrix posterior squared mean signals \\(E[\\mu_{\\ell t}^2|\\mathbf{y}_{1:T}]\\). var_model: list. List var-scp posterior parameters: pi_bar: numeric matrix. \\(T \\times K\\) matrix posterior change-point location probabilities. v_bar: numeric matrix. \\(T \\times K\\) matrix posterior rate parameters. u_bar: numeric vector. length \\(T\\) vector posterior shape parameters. lambda_bar: numeric matrix. \\(T \\times K\\) matrix posterior precision signals \\(E[\\lambda_{kt}|\\mathbf{y}_{1:T}]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu2_bar_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected Squared-Mean Signal â€” mu2_bar_fn","title":"Expected Squared-Mean Signal â€” mu2_bar_fn","text":"Given \\(E[y_t|b,\\tau]=\\mu_t=bI(t\\geq \\tau)\\), \\(P(\\tau=t)=\\pi_t\\), \\(\\bar{b}_t=E[b|\\tau=t]\\), \\(\\bar{\\omega}_t=V(b|\\tau=t)\\), mu2_bar_fn() calculates \\(E[\\mu^2_t]\\) \\(\\Sigma_{t'=1}^t (\\bar{b}^2_{t'} + 1 / \\bar{\\omega}_{t'})\\pi_{t'}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu2_bar_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected Squared-Mean Signal â€” mu2_bar_fn","text":"","code":"mu2_bar_fn(b, omega, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/mu2_bar_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected Squared-Mean Signal â€” mu2_bar_fn","text":"b numeric vector. Length \\(T\\) vector conditional mean parameters. omega numeric vector. Length \\(T\\) vector conditional variance parameters. prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu2_bar_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected Squared-Mean Signal â€” mu2_bar_fn","text":"numeric vector. length \\(T\\) vector \\(E[\\mu_t]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu2_lambda_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected Squared-Mean-Precision Signal â€” mu2_lambda_fn","title":"Expected Squared-Mean-Precision Signal â€” mu2_lambda_fn","text":"Given \\(E[y_t|b,\\tau]=\\mu_t=bI(t\\geq \\tau)\\), \\(\\bar{b}_t=E[b|\\tau=t]\\), \\(V(y_t|s,\\tau)=1/\\lambda_t=1/s^{(t\\geq \\tau)}\\), \\(\\bar{u}_t/\\bar{v}_t=E[s|\\tau=t]\\), \\(P(\\tau=t)=\\pi_t\\), mu_lambda_fn() calculates \\(E[\\mu^2_t\\lambda_t]\\) \\(\\Sigma_{t'=1}^t \\pi_{t'}(\\bar{b}^2_{t'}\\bar{v}_{t'} / \\bar{u}_{t'} + 1/\\bar{\\omega}_{t'})\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu2_lambda_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected Squared-Mean-Precision Signal â€” mu2_lambda_fn","text":"","code":"mu2_lambda_fn(b, omega, u, v, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/mu2_lambda_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected Squared-Mean-Precision Signal â€” mu2_lambda_fn","text":"b numeric vector. Length \\(T\\) vector conditional mean parameters. omega numeric vector. Length \\(T\\) vector conditional variance parameters. u numeric vector. Length \\(T\\) vector conditional shape parameters v numeric vector. Length \\(T\\) vector conditional rate parameters prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu2_lambda_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected Squared-Mean-Precision Signal â€” mu2_lambda_fn","text":"numeric vector. length \\(T\\) vector \\(E[\\mu^2_t\\lambda_t]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu_bar_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected Mean Signal â€” mu_bar_fn","title":"Expected Mean Signal â€” mu_bar_fn","text":"Given \\(E[y_t|b,\\tau]=\\mu_t=bI(t\\geq \\tau)\\), \\(P(\\tau=t)=\\pi_t\\), \\(\\bar{b}_t=E[b|\\tau=t]\\), mu_bar_fn() calculates \\(E[\\mu_t]\\) \\(\\Sigma_{t'=1}^t \\bar{b}_{t'}\\pi_{t'}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu_bar_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected Mean Signal â€” mu_bar_fn","text":"","code":"mu_bar_fn(b, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/mu_bar_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected Mean Signal â€” mu_bar_fn","text":"b numeric vector. Length \\(T\\) vector conditional mean parameters. prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu_bar_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected Mean Signal â€” mu_bar_fn","text":"numeric vector. length \\(T\\) vector \\(E[\\mu_t]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu_lambda_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected Mean-Precision Signal â€” mu_lambda_fn","title":"Expected Mean-Precision Signal â€” mu_lambda_fn","text":"Given \\(E[y_t|b,\\tau]=\\mu_t=bI(t\\geq \\tau)\\), \\(\\bar{b}_t=E[b|\\tau=t]\\), \\(\\bar{\\omega}_t=V(b|\\tau=t)\\), \\(V(y_t|s,\\tau)=1/\\lambda_t=1/s^{(t\\geq \\tau)}\\), \\(\\bar{u}_t/\\bar{v}_t=E[s|\\tau=t]\\), \\(P(\\tau=t)=\\pi_t\\), mu_lambda_fn() calculates \\(E[\\mu_t\\lambda_t]\\) \\(\\Sigma_{t'=1}^t \\bar{b}_{t'}\\bar{v}_{t'} \\pi_{t'}/ \\bar{u}_{t'}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu_lambda_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected Mean-Precision Signal â€” mu_lambda_fn","text":"","code":"mu_lambda_fn(b, u, v, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/mu_lambda_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected Mean-Precision Signal â€” mu_lambda_fn","text":"b numeric vector. Length \\(T\\) vector conditional mean parameters. u numeric vector. Length \\(T\\) vector conditional shape parameters v numeric vector. Length \\(T\\) vector conditional rate parameters prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/mu_lambda_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected Mean-Precision Signal â€” mu_lambda_fn","text":"numeric vector. length \\(T\\) vector \\(E[\\mu_t\\lambda_t]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mean_scp.html","id":null,"dir":"Reference","previous_headings":"","what":"Mulitvariate Mean Single Change-Point Model â€” multi_mean_scp","title":"Mulitvariate Mean Single Change-Point Model â€” multi_mean_scp","text":"Implementation multivariate Mean-SCP model Berlind, Cappello, Madrid Padilla (2025). function mean_scp() takes \\(T\\times d\\) matrix \\(\\mathbf{y}_{1:T}\\) single mean change returns posterior distribution change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mean_scp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mulitvariate Mean Single Change-Point Model â€” multi_mean_scp","text":"","code":"multi_mean_scp(y, omega_bar, log_omega_bar, log_pi)"},{"path":"https://davis-berlind.github.io/mich/reference/multi_mean_scp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mulitvariate Mean Single Change-Point Model â€” multi_mean_scp","text":"y numeric matrix. \\(T\\times d\\) matrix observations single mean change. omega_bar numeric vector. Posterior precision parameters \\(\\bar{\\omega}_t\\) \\(\\bar{\\Omega}_t = \\bar{\\omega}_t\\mathbf{}_d\\). log_omega_bar numeric vector. Log omega_bar. log_pi numeric vector. Vector log prior probabilities location change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mean_scp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mulitvariate Mean Single Change-Point Model â€” multi_mean_scp","text":"list. list posterior parameters including mean b_bar, posterior probabilities change-point location pi_bar.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mich_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate MICH Algorithm â€” multi_mich_cpp","title":"Multivariate MICH Algorithm â€” multi_mich_cpp","text":"Implementation Algorithm 3 Berlind, Cappello, Madrid Padilla (2025). algorithm takes sequence \\(d\\)-dimensional observations \\(\\mathbf{y}_{1:T}\\), iteratively fits \\(L\\) mean-scp models resulting variational approximation posterior distribution \\(L\\) mean change-points. algorithm terminates percentage increase ELBO falls tol.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mich_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate MICH Algorithm â€” multi_mich_cpp","text":"","code":"multi_mich_cpp(   y,   mu_0,   fit_intercept,   refit,   max_iter,   tol,   verbose,   omega_l,   log_pi_l,   omega_bar_l,   log_omega_bar_l,   post_params )"},{"path":"https://davis-berlind.github.io/mich/reference/multi_mich_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate MICH Algorithm â€” multi_mich_cpp","text":"y numeric matrix. \\(T \\times d\\) matrix observations. mu_0 numeric vector. Vector intercept parameters. fit_intercept logical. fit_intercept == TRUE, intercept estimated mu_0 gets updated. refit logical. refit == TRUE, MICH algorithm initialized fit provided post_params, otherwise null model \\(\\boldsymbol{\\mu}_t = \\mathbf{0}\\) \\(\\bar{\\pi}_{\\ell t} = 1/T\\) used initialization. max_iter integer. Maximum number iterations. ELBO converge max_iter reached, converged == FALSE returned fit object. tol scalar. Convergence tolerance relative increase ELBO. verbose logical. verbose == TRUE, value ELBO printed every 5000th iteration. omega_l scalar. Prior precision parameter mean-scp components model. log_pi_l numeric matrix. \\(T \\times L\\) matrix prior log change-point location probabilities \\(L\\) mean change-points. omega_bar_l, log_omega_bar_l Numeric vectors. Vector posterior precision parameters \\(\\{\\bar{\\omega}_t\\}_{t=1}^T\\) log evaluations \\(V(\\mathbf{b}_\\ell|\\tau=t) = \\bar{\\omega}_t\\mathbf{}_d\\). post_params list. length \\(L\\) list posterior parameters mean-scp component. element list list containing \\(T\\times L\\) matrix posterior mean parameters length \\(T\\) vectors posterior change-point location probabilities log evaluations.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mich_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate MICH Algorithm â€” multi_mich_cpp","text":"List. Parameters variational approximation MICH posterior distribution, including: L: integer. Number components included model. residual: numeric matrix. Residual \\(\\mathbf{r}_{1:T}\\) subtracting \\(E[\\boldsymbol{\\mu}_{\\ell t}]\\) \\(\\mathbf{y}_{1:T}\\). mu: numeric matrix. Posterior estimate \\(\\Sigma_{\\ell=1}^L E[\\boldsymbol{\\mu}_{\\ell,1:T}|\\mathbf{y}_{1:T}]\\). mu_0: numeric vector. Estimate intercept. post_params: list. List posterior parameters mean-scp component. elbo: numeric vector. Value ELBO iteration. converged: logical. Indicates whether relative increase ELBO less tol.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu2_bar_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate Expected Squared-Mean Signal â€” multi_mu2_bar_fn","title":"Multivariate Expected Squared-Mean Signal â€” multi_mu2_bar_fn","text":"Given \\(E[\\mathbf{y}_t|\\mathbf{b},\\tau] = \\mathbf{b}(t\\geq \\tau)\\), \\(P(\\tau = t)=\\pi_t\\), \\(1\\leq \\leq d\\), \\(\\bar{b}_{}=E[b_i|\\tau=t]\\) \\(\\bar{\\omega}_{}=V(b_i|\\tau=t)\\), multi_mu2_bar_fn() calculates \\(E[b_i^2I(t\\geq \\tau)]\\) \\(\\Sigma_{t'=1}^t (\\bar{b}^2_{'} + 1/\\bar{\\omega}_{'}) \\pi_{t'}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu2_bar_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate Expected Squared-Mean Signal â€” multi_mu2_bar_fn","text":"","code":"multi_mu2_bar_fn(b, omega, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu2_bar_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate Expected Squared-Mean Signal â€” multi_mu2_bar_fn","text":"b numeric matrix. \\(T\\times d\\) matrix conditional mean parameters. omega numeric vector. Length \\(T\\) vector conditional variance parameters. prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu2_bar_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate Expected Squared-Mean Signal â€” multi_mu2_bar_fn","text":"numeric matrix. \\(T\\times d\\) matrix \\(E[b^2_iI(t\\geq \\tau)]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu_bar_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate Expected Mean Signal â€” multi_mu_bar_fn","title":"Multivariate Expected Mean Signal â€” multi_mu_bar_fn","text":"Given \\(E[\\mathbf{y}_t|\\mathbf{b},\\tau] = \\mathbf{b}(t\\geq \\tau)\\), \\(P(\\tau = t)=\\pi_t\\), \\(\\bar{\\mathbf{b}}_t=E[\\mathbf{b}|\\tau=t]\\), multi_mu_bar_fn() calculates \\(E[\\mathbf{b}(t\\geq \\tau)]\\) \\(\\Sigma_{t'=1}^t \\bar{\\mathbf{b}}_{t'}\\pi_{t'}\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu_bar_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate Expected Mean Signal â€” multi_mu_bar_fn","text":"","code":"multi_mu_bar_fn(b, prob)"},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu_bar_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate Expected Mean Signal â€” multi_mu_bar_fn","text":"b numeric matrix. \\(T\\times d\\) matrix conditional mean parameters. prob numeric vector. Vector change-point location probabilities.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/multi_mu_bar_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate Expected Mean Signal â€” multi_mu_bar_fn","text":"numeric matrix. \\(T\\times d\\) matrix \\(E[\\mathbf{b}(t\\geq \\tau)]\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/plot.mich.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for mich.fit objects â€” plot.mich.fit","title":"Plot method for mich.fit objects â€” plot.mich.fit","text":"Plots resulting fit estimated change-points calling mich().","code":""},{"path":"https://davis-berlind.github.io/mich/reference/plot.mich.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for mich.fit objects â€” plot.mich.fit","text":"","code":"# S3 method for class 'mich.fit' plot(   x,   level = 0.95,   max_length = NULL,   signal = FALSE,   cs = TRUE,   n_plots = 5,   ... )"},{"path":"https://davis-berlind.github.io/mich/reference/plot.mich.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for mich.fit objects â€” plot.mich.fit","text":"x mich.fit object. Output running mich() numeric vector matrix. level scalar. number (0,1) indicating significance level construct credible sets cs == TRUE. max_length integer. Detection threshold, see mich_sets(). Equal \\(\\log^{2}(T)\\) default. signal logical. TRUE, posterior mean precision signals also plotted. cs logical. TRUE, level-level credible sets detected change-point also plotted. n_plots integer. Number plot display data y matrix. ... Additional arguments passed methods.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/plot.mich.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for mich.fit objects â€” plot.mich.fit","text":"Invisibly returns NULL.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/plot.mich.fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot method for mich.fit objects â€” plot.mich.fit","text":"","code":"set.seed(222) # generate univariate data with two mean-variance change-points y = c(rnorm(100,0,10), rnorm(100,10,3), rnorm(100,0,6)) fit = mich(y, J = 2) # fit two mean-variance change-points # plot change-points with 95% credible sets plot(fit, level = 0.95, cs = TRUE)  # fit one mean and one mean-variance change-point fit = mich(y, J = 1, L = 1) # plot change-points with 95% credible sets and signal plot(fit, level = 0.95, cs = TRUE, signal = TRUE)   # generate correlated mulitvariate data with two mean-variance change-points T <- 150 Sigma <- rbind(c(1, 0.7), c(0.7, 2)) d <- ncol(Sigma) Sigma_eigen <- eigen(Sigma) e_vectors <- Sigma_eigen$vectors e_values <- Sigma_eigen$values Sigma_sd <- e_vectors %*% diag(sqrt(e_values)) %*% t(e_vectors) Z <- sapply(1:d, function(i) rnorm(T)) mu <- c(-1, 2) mu_t <- matrix(0, nrow = 70, ncol=d) mu_t <- rbind(mu_t, t(sapply(1:30, function(i) mu))) mu_t <- rbind(mu_t, matrix(0, nrow = 50, ncol = d)) Y <- mu_t + Z %*% Sigma_sd # fit MICH and pick L automatically using ELBO fit = mich(Y, L_auto = TRUE) plot(fit, level = 0.95, cs = TRUE, signal = TRUE)"},{"path":"https://davis-berlind.github.io/mich/reference/prob_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Probability vector check. â€” prob_check","title":"Probability vector check. â€” prob_check","text":"prob_check() throws error probs either one string arguments 'uniform' 'weighted', length \\(T\\) vector elements sum one, \\(T \\times n\\) matrix columns sum one.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/prob_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probability vector check. â€” prob_check","text":"","code":"prob_check(probs, n, T)"},{"path":"https://davis-berlind.github.io/mich/reference/prob_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probability vector check. â€” prob_check","text":"probs character, numeric vector, numeric matrix. character, probs equal 'weighted' 'uniform'. vector, elements probs must sum one. matrix, rows probs must sum one. n integer. Number columns probs matrix. T integer. Length number rows probs.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/prob_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probability vector check. â€” prob_check","text":"character, numeric vector, numeric matrix. error thrown evaluation, prob_check() returns probs argument.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/revcumsum.html","id":null,"dir":"Reference","previous_headings":"","what":"Reverse cumulative sum â€” revcumsum","title":"Reverse cumulative sum â€” revcumsum","text":"revcumsum() takes length \\(n\\) vector \\(\\{x_i\\}_{=1}^n\\) returns \\(\\{\\Sigma_{j=}^n x_j\\}_{=1}^n\\).","code":""},{"path":"https://davis-berlind.github.io/mich/reference/revcumsum.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reverse cumulative sum â€” revcumsum","text":"","code":"revcumsum(x)"},{"path":"https://davis-berlind.github.io/mich/reference/revcumsum.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reverse cumulative sum â€” revcumsum","text":"x numeric vector.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/revcumsum.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reverse cumulative sum â€” revcumsum","text":"numeric vector. Reverse cumulative sum elements x.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/revcumsum.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reverse cumulative sum â€” revcumsum","text":"","code":"revcumsum(1:10) #>  [1] 55 54 52 49 45 40 34 27 19 10"},{"path":"https://davis-berlind.github.io/mich/reference/scalar_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Scalar value check. â€” scalar_check","title":"Scalar value check. â€” scalar_check","text":"scalar_check() throws error x equal scalar value.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/scalar_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scalar value check. â€” scalar_check","text":"","code":"scalar_check(x)"},{"path":"https://davis-berlind.github.io/mich/reference/scalar_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scalar value check. â€” scalar_check","text":"x scalar.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/scalar_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scalar value check. â€” scalar_check","text":"scalar error thrown evaluation, scalar_check() returns x argument.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/summary.mich.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for mich.fit objects â€” summary.mich.fit","title":"Summary method for mich.fit objects â€” summary.mich.fit","text":"Prints summary resulting fit calling mich(), including ELBO fitted model, estimated change-points level-level credible sets.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/summary.mich.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for mich.fit objects â€” summary.mich.fit","text":"","code":"# S3 method for class 'mich.fit' summary(object, level = 0.95, max_length = NULL, ...)"},{"path":"https://davis-berlind.github.io/mich/reference/summary.mich.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for mich.fit objects â€” summary.mich.fit","text":"object mich.fit object. Output running mich() numeric vector matrix. level scalar. number (0,1) indicating significance level construct credible sets . max_length integer. Detection threshold, see mich_sets(). Equal \\(\\log^{2}(T)\\) default. ... Additional arguments passed methods.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/summary.mich.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary method for mich.fit objects â€” summary.mich.fit","text":"list. list summary quantities including: elbo: value ELBO model. converged: Indicator whether model converged. level: significance level used construct credible sets. L,K,J: number mean-scp, var-scp, meanvar-scp components included model. mean_cp,var_cp,meanvar_cp: Lists cp, estimated change-points, sets, corresponding level-level credible sets.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/var_scp.html","id":null,"dir":"Reference","previous_headings":"","what":"Variance Single Change-Point Model â€” var_scp","title":"Variance Single Change-Point Model â€” var_scp","text":"Implementation Var-SCP model Berlind, Cappello, Madrid Padilla (2025). function var_scp() takes length \\(T\\) vector \\(y_{1:T}\\) single variance change returns posterior distribution change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/var_scp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variance Single Change-Point Model â€” var_scp","text":"","code":"var_scp(y, omega, u_bar, lgamma_u_bar, v, log_pi)"},{"path":"https://davis-berlind.github.io/mich/reference/var_scp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variance Single Change-Point Model â€” var_scp","text":"y numeric vector. \\(T\\) observations single variance change. omega numeric vector. Known trend component precision y. u_bar numeric vector. Posterior shape parameters equal \\(u_0 + T - t + 1\\) \\(t\\). lgamma_u_bar numeric vector. Log gamma function evaluated u_bar. v numeric vector. Vector prior rate parameters \\(t\\). log_pi numeric vector. Vector log prior probabilities location change-point.","code":""},{"path":"https://davis-berlind.github.io/mich/reference/var_scp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variance Single Change-Point Model â€” var_scp","text":"list. list posterior parameters including rate v_bar, posterior probabilities change-point location pi_bar.","code":""},{"path":"https://davis-berlind.github.io/mich/news/index.html","id":"mich-001","dir":"Changelog","previous_headings":"","what":"mich 0.0.1","title":"mich 0.0.1","text":"initial release version mich. release introduces: Main package function mich(). Summary plotting S3 methods mich.fit class. NEWS.md file track changes package. Weighted prior functions log_mean_prior(), log_var_prior(), log_meanvar_prior. Datasets well_log.csv, ion_channel.csv, steps.csv Introduction","code":""}]
