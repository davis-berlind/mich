# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Multivariate Expected Mean Signal
#'
#' @description
#' Given that \eqn{E[\mathbf{y}_t|\mathbf{b},\tau] = \mathbf{b}I(t\geq \tau)},
#' \eqn{P(\tau = t)=\pi_t}, and \eqn{\bar{\mathbf{b}}_t=E[\mathbf{b}|\tau=t]},
#' `multi_mu_bar_fn()` calculates \eqn{E[\mathbf{b}I(t\geq \tau)]} as
#' \eqn{\Sigma_{t'=1}^t \bar{\mathbf{b}}_{t'}\pi_{t'}}.
#'
#' @keywords internal
#'
#' @param b A numeric matrix. \eqn{T\times d} matrix of conditional mean
#'   parameters.
#' @param prob A numeric vector. Vector of change-point location probabilities.
#'
#' @return A numeric matrix. A \eqn{T\times d} matrix of
#' \eqn{E[\mathbf{b}I(t\geq \tau)]}.
#'
multi_mu_bar_fn <- function(b, prob) {
    .Call(`_mich_multi_mu_bar_fn`, b, prob)
}

#' Multivariate Expected Squared-Mean Signal
#'
#' @description
#' Given that \eqn{E[\mathbf{y}_t|\mathbf{b},\tau] = \mathbf{b}I(t\geq \tau)},
#' \eqn{P(\tau = t)=\pi_t}, and for some \eqn{1\leq i \leq d},
#' \eqn{\bar{b}_{it}=E[b_i|\tau=t]} and \eqn{\bar{\omega}_{it}=V(b_i|\tau=t)},
#' `multi_mu2_bar_fn()` calculates \eqn{E[b_i^2I(t\geq \tau)]} as
#' \eqn{\Sigma_{t'=1}^t (\bar{b}^2_{it'} + 1/\bar{\omega}_{it'}) \pi_{t'}}.
#'
#' @keywords internal
#'
#' @param b A numeric matrix. \eqn{T\times d} matrix of conditional mean
#'   parameters.
#' @param omega A numeric vector. Length \eqn{T} vector of conditional variance
#'   parameters.
#' @param prob A numeric vector. Vector of change-point location probabilities.
#'
#' @return A numeric matrix. A \eqn{T\times d} matrix of
#' \eqn{E[b^2_iI(t\geq \tau)]}.
#'
multi_mu2_bar_fn <- function(b, omega, prob) {
    .Call(`_mich_multi_mu2_bar_fn`, b, omega, prob)
}

#' Expected Mean Signal
#'
#' @description
#' Given that \eqn{E[y_t|b,\tau]=\mu_t=bI(t\geq \tau)}, \eqn{P(\tau=t)=\pi_t},
#' and \eqn{\bar{b}_t=E[b|\tau=t]}, `mu_bar_fn()` calculates \eqn{E[\mu_t]} as
#' \eqn{\Sigma_{t'=1}^t \bar{b}_{t'}\pi_{t'}}.
#'
#' @keywords internal
#'
#' @param b A numeric vector. Length \eqn{T} vector of conditional mean
#'   parameters.
#' @param prob A numeric vector. Vector of change-point location probabilities.
#'
#' @return A numeric vector. A length \eqn{T} vector of \eqn{E[\mu_t]}.
#'
mu_bar_fn <- function(b, prob) {
    .Call(`_mich_mu_bar_fn`, b, prob)
}

#' Expected Squared-Mean Signal
#'
#' @description
#' Given that \eqn{E[y_t|b,\tau]=\mu_t=bI(t\geq \tau)}, \eqn{P(\tau=t)=\pi_t},
#' \eqn{\bar{b}_t=E[b|\tau=t]}, and \eqn{\bar{\omega}_t=V(b|\tau=t)},
#' `mu2_bar_fn()` calculates \eqn{E[\mu^2_t]} as
#' \eqn{\Sigma_{t'=1}^t (\bar{b}^2_{t'} + 1 / \bar{\omega}_{t'})\pi_{t'}}.
#'
#' @keywords internal
#'
#' @param b A numeric vector. Length \eqn{T} vector of conditional mean
#'   parameters.
#' @param omega A numeric vector. Length \eqn{T} vector of conditional variance
#'   parameters.
#' @param prob A numeric vector. Vector of change-point location probabilities.
#'
#' @return A numeric vector. A length \eqn{T} vector of \eqn{E[\mu_t]}.
#'
mu2_bar_fn <- function(b, omega, prob) {
    .Call(`_mich_mu2_bar_fn`, b, omega, prob)
}

#' Expected Precision Signal
#'
#' @description
#' Given that \eqn{V(y_t|s,\tau)=1/\lambda_t=1/s^{I(t\geq \tau)}},
#' \eqn{P(\tau=t)=\pi_t}, and \eqn{\bar{u}_t/\bar{v}_t=E[s|\tau=t]},
#' `lambda_bar_fn()` calculates \eqn{E[\lambda_t]} as
#' \eqn{1 - \Sigma_{t'=1}^t \pi_{t'}(1 - \bar{v}_{t'} / \bar{u}_{t'})}.
#'
#' @keywords internal
#'
#' @param u A numeric vector. Length \eqn{T} vector of conditional shape
#'   parameters
#' @param v A numeric vector. Length \eqn{T} vector of conditional rate
#'   parameters
#' @param prob A numeric vector. Vector of change-point location probabilities.
#'
#' @return A numeric vector. A length \eqn{T} vector of \eqn{E[\lambda_t]}.
#'
lambda_bar_fn <- function(u, v, prob) {
    .Call(`_mich_lambda_bar_fn`, u, v, prob)
}

#' Expected Mean-Precision Signal
#'
#' @description
#' Given that \eqn{E[y_t|b,\tau]=\mu_t=bI(t\geq \tau)},
#' \eqn{\bar{b}_t=E[b|\tau=t]}, \eqn{\bar{\omega}_t=V(b|\tau=t)},
#' \eqn{V(y_t|s,\tau)=1/\lambda_t=1/s^{I(t\geq \tau)}},
#' \eqn{\bar{u}_t/\bar{v}_t=E[s|\tau=t]}, and \eqn{P(\tau=t)=\pi_t},
#' `mu_lambda_fn()` calculates \eqn{E[\mu_t\lambda_t]} as
#' \eqn{\Sigma_{t'=1}^t \bar{b}_{t'}\bar{v}_{t'} \pi_{t'}/ \bar{u}_{t'}}.
#'
#' @keywords internal
#'
#' @param b A numeric vector. Length \eqn{T} vector of conditional mean
#'   parameters.
#' @param u A numeric vector. Length \eqn{T} vector of conditional shape
#'   parameters
#' @param v A numeric vector. Length \eqn{T} vector of conditional rate
#'   parameters
#' @param prob A numeric vector. Vector of change-point location probabilities.
#'
#' @return A numeric vector. A length \eqn{T} vector of
#' \eqn{E[\mu_t\lambda_t]}.
#'
mu_lambda_fn <- function(b, u, v, prob) {
    .Call(`_mich_mu_lambda_fn`, b, u, v, prob)
}

#' Expected Squared-Mean-Precision Signal
#'
#' @description
#' Given that \eqn{E[y_t|b,\tau]=\mu_t=bI(t\geq \tau)},
#' \eqn{\bar{b}_t=E[b|\tau=t]},
#' \eqn{V(y_t|s,\tau)=1/\lambda_t=1/s^{I(t\geq \tau)}},
#' \eqn{\bar{u}_t/\bar{v}_t=E[s|\tau=t]}, and \eqn{P(\tau=t)=\pi_t},
#' `mu_lambda_fn()` calculates \eqn{E[\mu^2_t\lambda_t]} as
#' \eqn{\Sigma_{t'=1}^t \pi_{t'}(\bar{b}^2_{t'}\bar{v}_{t'} / \bar{u}_{t'} + 1/\bar{\omega}_{t'})}.
#'
#' @keywords internal
#'
#' @param b A numeric vector. Length \eqn{T} vector of conditional mean
#'   parameters.
#' @param u A numeric vector. Length \eqn{T} vector of conditional shape
#'   parameters
#' @param omega A numeric vector. Length \eqn{T} vector of conditional variance
#'   parameters.
#' @param v A numeric vector. Length \eqn{T} vector of conditional rate
#'   parameters
#' @param prob A numeric vector. Vector of change-point location probabilities.
#'
#' @return A numeric vector. A length \eqn{T} vector of
#' \eqn{E[\mu^2_t\lambda_t]}.
#'
mu2_lambda_fn <- function(b, omega, u, v, prob) {
    .Call(`_mich_mu2_lambda_fn`, b, omega, u, v, prob)
}

#' MICH Algorithm
#'
#' @description
#' Implementation of Algorithms 1 & 2 in Berlind, Cappello, and Madrid Padilla
#' (2025). This algorithm takes a sequence of \eqn{T} observations
#' \eqn{\mathbf{y}_{1:T}}, and iteratively fits \eqn{L} mean-scp models,
#' \eqn{K} var-scp models, and \eqn{J} meanvar-scp models resulting in a
#' variational approximation to the posterior distribution of
#' the \eqn{L} mean, \eqn{K} variance, and \eqn{J} mean and variance
#' change-points. The algorithm terminates once the percentage increase in the
#' ELBO falls below `tol`.
#'
#' @param y A numeric vector. Length \eqn{T} vector of observations.
#' @param L,K,J Integers. The number of mean, variance, and mean-variance
#'   change-points to include in the model.
#' @param mu_0 A scalar. Intercept parameter initialization.
#' @param lambda_0 A scalar. Baseline scale parameter initialization.
#' @param fit_intercept A logical. If `fit_intercept == TRUE`, then an
#'   intercept is estimated and `mu_0` gets updated.
#' @param fit_scale A logical. If `fit_scale == TRUE`, then an initial scale is
#'   estimated and `lambda_0` gets updated.
#' @param refit A logical. If `refit == TRUE`, then the MICH algorithm is
#'   initialized using the provided posterior parameters, otherwise the null
#'   model \eqn{\mu_t = 0}, \eqn{\lambda_t = 1} and
#'   \eqn{\bar{\pi}_{\ell t} = \bar{\pi}_{k t} = \bar{\pi}_{j t}  = 1/T} is
#'   used as the initialization.
#' @param max_iter An integer. Maximum number of iterations. If ELBO does not
#'   converge before `max_iter` is reached, then `converged == FALSE` in the
#'   returned fit object.
#' @param verbose A logical. If `verbose == TRUE`, then value of the ELBO is
#'   printed every 5000th iteration.
#' @param tol A scalar. Convergence tolerance for relative increase in ELBO.
#' @param omega_j,u_j,v_j Scalars. Prior precision, shape, and rate parameters
#'   for meanvar-scp components of model.
#' @param log_pi_j A numeric matrix. A \eqn{T \times J} matrix of prior log
#'   change-point location probabilities for each of the \eqn{J} mean-variance
#'   change-points.
#' @param pi_bar_j,log_pi_bar_j Numeric matrices. \eqn{T \times J} matrices of
#'   initialized posterior change-point location probabilities and their log
#'   evaluations for the \eqn{J} mean-variance change-points.
#' @param b_bar_j A numeric matrix. A \eqn{T \times J} matrix of initialized
#'   posterior mean parameters of the \eqn{J} mean-variance change-points.
#' @param omega_bar_j A numeric matrix. A \eqn{T\times J} matrix of initialized
#'   posterior precision parameters of the \eqn{J} mean-variance change-points.
#' @param v_bar_j A numeric matrix. A \eqn{T \times J} matrix of initialized
#'   posterior rate parameters for the \eqn{J} mean-variance change-points.
#' @param u_bar_j,lgamma_u_bar_j,digamma_u_bar_j Numeric vectors. Length
#'   \eqn{T} vectors of posterior shape parameters for the meanvar-scp model
#'   components and their log-gamma and digamma evaluations.
#' @param omega_l A scalar. Prior precision parameter for mean-scp components
#'   of model.
#' @param log_pi_l A numeric matrix. A \eqn{T \times L} matrix of prior log
#'   change-point location probabilities for each of the \eqn{L} mean
#'   change-points.
#' @param pi_bar_l,log_pi_bar_l Numeric matrices. \eqn{T \times L} matrices of
#'   initialized posterior change-point location probabilities and their log
#'   evaluations for the \eqn{L} mean change-points.
#' @param b_bar_l A numeric matrix. A \eqn{T \times L} matrix of initialized
#'   posterior mean parameters of the \eqn{L} mean change-points.
#' @param omega_bar_l A numeric matrix. A \eqn{T\times L} matrix of initialized
#'   posterior precision parameters of the \eqn{L} mean change-points.
#' @param u_k,v_k Scalars. Prior shape and rate parameters for var-scp
#'   components of model.
#' @param log_pi_k A numeric matrix. A \eqn{T \times K} matrix of prior log
#'   change-point location probabilities for each of the \eqn{K} variance
#'   change-points.
#' @param pi_bar_k,log_pi_bar_k Numeric matrices. \eqn{T \times K} matrices of
#'   initialized posterior change-point location probabilities and their log
#'   evaluations for the \eqn{K} variance change-points.
#' @param v_bar_k A numeric matrix. A \eqn{T \times K} matrix of initialized
#'   posterior rate parameters for the \eqn{K} variance change-points.
#' @param u_bar_k,lgamma_u_bar_k,digamma_u_bar_k Numeric vectors. Length
#'   \eqn{T} vectors of posterior shape parameters for the var-scp model
#'   components and their log-gamma and digamma evaluations.
#'
#' @return A List. Parameters of the variational approximation the MICH
#' posterior distribution, including:
#'   * `y`: A numeric vector. Original data set.
#'   * `residual`: A numeric vector. Residual \eqn{\mathbf{r}_{1:T}} after
#'     subtracting out each \eqn{E[\mu_{\ell t}]} and \eqn{E[\lambda_{j t} \mu_{j t}]/E[\lambda_{j t}]}
#'     from \eqn{\mathbf{y}_{1:T}}.
#'   * `mu`: A numeric vector. Posterior estimate of
#'     \eqn{\Sigma_{\ell=1}^L E[\mu_{\ell,1:T}|\mathbf{y}_{1:T}] + \Sigma_{j=1}^J E[\mu_{j,1:T}|\mathbf{y}_{1:T}]}.
#'   * `lambda`: A numeric vector. Posterior estimate of
#'     \eqn{\Pi_{\\k=1}^K E[\lambda_{k,1:T}|\mathbf{y}_{1:T}] \times \Pi_{j=1}^J E[\lambda_{j,1:T}|\mathbf{y}_{1:T}]}.
#'   * `delta`: A numeric vector. Posterior variance correction term (see
#'     (B.6) or Berlind, Cappello, and Madrid Padilla (2025)).
#'   * `converged`: A logical. Indicates whether relative increase in the ELBO
#'     is less than `tol`.
#'   * `elbo`: A numeric vector. Value of the ELBO after each iteration.
#'   * `mu_0`: A scalar. Estimate of the intercept.
#'   * `lambda_0`: A scalar. Estimate of the initial precision.
#'   * `J`, `L`, `K`: Integers. number of mean, variance, and mean-variance
#'     components.
#'   * `J_model`: A list. A list of the posterior parameters for each of the
#'     \eqn{J} meanvar-scp components (only included in `J > 0`).
#'   * `L_model`: A list. A list of the posterior parameters for each of the
#'     \eqn{L} mean-scp components (only included in `L > 0`).
#'   * `K_model`: A list. A list of the posterior parameters for each of the
#'     \eqn{K} var-scp components (only included in `K > 0`).
#'
mich_cpp <- function(y, J, L, K, mu_0, lambda_0, fit_intercept, fit_scale, refit, max_iter, verbose, tol, omega_j, u_j, v_j, log_pi_j, pi_bar_j, log_pi_bar_j, b_bar_j, omega_bar_j, u_bar_j, v_bar_j, lgamma_u_bar_j, digamma_u_bar_j, omega_l, log_pi_l, pi_bar_l, log_pi_bar_l, b_bar_l, omega_bar_l, u_k, v_k, log_pi_k, pi_bar_k, log_pi_bar_k, u_bar_k, v_bar_k, lgamma_u_bar_k, digamma_u_bar_k) {
    .Call(`_mich_mich_cpp`, y, J, L, K, mu_0, lambda_0, fit_intercept, fit_scale, refit, max_iter, verbose, tol, omega_j, u_j, v_j, log_pi_j, pi_bar_j, log_pi_bar_j, b_bar_j, omega_bar_j, u_bar_j, v_bar_j, lgamma_u_bar_j, digamma_u_bar_j, omega_l, log_pi_l, pi_bar_l, log_pi_bar_l, b_bar_l, omega_bar_l, u_k, v_k, log_pi_k, pi_bar_k, log_pi_bar_k, u_bar_k, v_bar_k, lgamma_u_bar_k, digamma_u_bar_k)
}

#' Multivariate MICH Algorithm
#'
#' @description
#' Implementation of Algorithm 3 from Berlind, Cappello, and Madrid Padilla
#' (2025). This algorithm takes a sequence of \eqn{d}-dimensional observations
#' \eqn{\mathbf{y}_{1:T}}, and iteratively fits \eqn{L} mean-scp models
#' resulting in a variational approximation to the posterior distribution of
#' the \eqn{L} mean change-points. The algorithm terminates once the
#' percentage increase in the ELBO falls below `tol`.
#'
#' @keywords internal
#'
#' @param y A numeric matrix. \eqn{T \times d} matrix of observations.
#' @param mu_0 A numeric vector. Vector of intercept parameters.
#' @param fit_intercept A logical. If `fit_intercept == TRUE`, then an
#'   intercept is estimated and `mu_0` gets updated.
#' @param refit A logical. If `refit == TRUE`, then the MICH algorithm is
#'   initialized by the fit provided in `post_params`, otherwise the null
#'   model \eqn{\boldsymbol{\mu}_t = \mathbf{0}} and
#'   \eqn{\bar{\pi}_{\ell t} = 1/T} is used as the initialization.
#' @param max_iter An integer. Maximum number of iterations. If ELBO does not
#'   converge before `max_iter` is reached, then `converged == FALSE` in the
#'   returned fit object.
#' @param tol A scalar. Convergence tolerance for relative increase in ELBO.
#' @param verbose A logical. If `verbose == TRUE`, then the value of the ELBO
#'   is printed every 5000th iteration.
#' @param omega_l A scalar. Prior precision parameter for mean-scp components
#'   of model.
#' @param log_pi_l A numeric matrix. A \eqn{T \times L} matrix of prior log
#'   change-point location probabilities for each of the \eqn{L} mean
#'   change-points.
#' @param omega_bar_l,log_omega_bar_l Numeric vectors. Vector of posterior
#'   precision parameters \eqn{\{\bar{\omega}_t\}_{t=1}^T} and log evaluations
#'   such that \eqn{V(\mathbf{b}_\ell|\tau=t) = \bar{\omega}_t\mathbf{I}_d}.
#' @param post_params A list. A length \eqn{L} list of the posterior parameters
#'   of each mean-scp component. Each element of the list is a list containing
#'   a \eqn{T\times L} matrix of posterior mean parameters and length \eqn{T}
#'   vectors of posterior change-point location probabilities and their log
#'   evaluations.
#'
#' @return A List. Parameters of the variational approximation the MICH
#' posterior distribution, including:
#'   * `L`: An integer. Number of components included in model.
#'   * `residual`: A numeric matrix. Residual \eqn{\mathbf{r}_{1:T}} after
#'     subtracting out each \eqn{E[\boldsymbol{\mu}_{\ell t}]} from
#'     \eqn{\mathbf{y}_{1:T}}.
#'   * `mu`: A numeric matrix. Posterior estimate of
#'     \eqn{\Sigma_{\ell=1}^L E[\boldsymbol{\mu}_{\ell,1:T}|\mathbf{y}_{1:T}]}.
#'   * `mu_0`: A numeric vector. Estimate of the intercept.
#'   * `post_params`: A list. List of posterior parameters for each mean-scp
#'     component.
#'   * `elbo`: A numeric vector. Value of the ELBO after each iteration.
#'   * `converged`: A logical. Indicates whether relative increase in the ELBO
#'     is less than `tol`.
#'
multi_mich_cpp <- function(y, mu_0, fit_intercept, refit, max_iter, tol, verbose, omega_l, log_pi_l, omega_bar_l, log_omega_bar_l, post_params) {
    .Call(`_mich_multi_mich_cpp`, y, mu_0, fit_intercept, refit, max_iter, tol, verbose, omega_l, log_pi_l, omega_bar_l, log_omega_bar_l, post_params)
}

#' Mean Single Change-Point Model
#'
#' @description
#' Implementation of the univariate Mean-SCP model from Berlind, Cappello, and
#' Madrid Padilla (2025). The function `mean_scp()` takes a length \eqn{T}
#' vector \eqn{y_{1:T}} with a single mean change and returns the posterior
#' distribution of the change-point.
#'
#' @param y A numeric vector. \eqn{T} observations with a single variance
#'   change.
#' @param lambda A numeric vector. Precision vector of `y`.
#' @param omega A positive scalar. Prior precision parameter.
#' @param log_pi A numeric vector. Vector of log prior probabilities for the
#'   location of the change-point.
#'
#' @return A list. A list of posterior parameters including the mean `b_bar`,
#' precision `omega_bar`, and posterior probabilities of the change-point
#' location `pi_bar`.
#'
#' @export
#'
mean_scp <- function(y, lambda, omega, log_pi) {
    .Call(`_mich_mean_scp`, y, lambda, omega, log_pi)
}

#' Mulitvariate Mean Single Change-Point Model
#'
#' @description
#' Implementation of the multivariate Mean-SCP model from Berlind, Cappello,
#' and Madrid Padilla (2025). The function `mean_scp()` takes a \eqn{T\times d}
#' matrix \eqn{\mathbf{y}_{1:T}} with a single mean change and returns the
#' posterior distribution of the change-point.
#'
#' @param y A numeric matrix. \eqn{T\times d} matrix of observations with a
#'   single mean change.
#' @param omega_bar A numeric vector. Posterior precision parameters
#'   \eqn{\bar{\omega}_t} such that
#'   \eqn{\bar{\Omega}_t = \bar{\omega}_t\mathbf{I}_d}.
#' @param log_omega_bar A numeric vector. Log of `omega_bar`.
#' @param log_pi A numeric vector. Vector of log prior probabilities for the
#'   location of the change-point.
#'
#' @return A list. A list of posterior parameters including the mean `b_bar`,
#' and posterior probabilities of the change-point location `pi_bar`.
#'
#' @export
#'
multi_mean_scp <- function(y, omega_bar, log_omega_bar, log_pi) {
    .Call(`_mich_multi_mean_scp`, y, omega_bar, log_omega_bar, log_pi)
}

#' Variance Single Change-Point Model
#'
#' @description
#' Implementation of the Var-SCP model from Berlind, Cappello, and Madrid
#' Padilla (2025). The function `var_scp()` takes a length \eqn{T} vector
#' \eqn{y_{1:T}} with a single variance change and returns the posterior
#' distribution of the change-point.
#'
#' @param y A numeric vector. \eqn{T} observations with a single variance
#'   change.
#' @param omega A numeric vector. Known trend component of precision of `y`.
#' @param u_bar A numeric vector. Posterior shape parameters equal to
#'   \eqn{u_0 + T - t + 1} for each \eqn{t}.
#' @param lgamma_u_bar A numeric vector. Log gamma function evaluated at u_bar.
#' @param v A numeric vector. Vector of prior rate parameters for each \eqn{t}.
#' @param log_pi A numeric vector. Vector of log prior probabilities for the
#'   location of the change-point.
#'
#' @return A list. A list of posterior parameters including the rate `v_bar`,
#' and posterior probabilities of the change-point location `pi_bar`.
#'
#' @export
#'
var_scp <- function(y, omega, u_bar, lgamma_u_bar, v, log_pi) {
    .Call(`_mich_var_scp`, y, omega, u_bar, lgamma_u_bar, v, log_pi)
}

#' Mean-Variance Single Change-Point Model
#'
#' @description
#' Implementation of the MeanVar-SCP model from Berlind, Cappello, and Madrid
#' Padilla (2025). The function `meanvar_scp()` takes a length \eqn{T} vector
#' \eqn{y_{1:T}} with a single joint mean and variance change and returns the
#' posterior distribution of the change-point.
#'
#' @param y A numeric vector. \eqn{T} observations with a single joint mean and
#' variance change.
#' @param lambda A numeric vector. Known trend component of precision of `y`.
#' @param omega A positive scalar. Prior precision parameter.
#' @param u_bar A numeric vector. Posterior shape parameters equal to
#'   \eqn{u_0 + T - t + 1} for each \eqn{t}.
#' @param lgamma_u_bar A numeric vector. Log gamma function evaluated at u_bar.
#' @param v A numeric vector. Vector of prior rate parameters for each \eqn{t}.
#' @param log_pi A numeric vector. Vector of log prior probabilities for the
#'   location of the change-point.
#'
#' @return A list. A list of posterior parameters including the  mean `b_bar`,
#' precision `omega_bar`, rate `v_bar`, and posterior probabilities of the
#' change-point location `pi_bar`.
#'
#' @export
#'
meanvar_scp <- function(y, lambda, omega, u_bar, lgamma_u_bar, v, log_pi) {
    .Call(`_mich_meanvar_scp`, y, lambda, omega, u_bar, lgamma_u_bar, v, log_pi)
}

